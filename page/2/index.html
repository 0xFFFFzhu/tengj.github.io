<!DOCTYPE html>
<html lang="zh-Hans">
<head>

    <!--[if lt IE 9]>
        <style>body {display: none; background: none !important} </style>
        <meta http-equiv="Refresh" Content="0; url=//outdatedbrowser.com/" />
    <![endif]-->

<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<meta name="format-detection" content="telephone=no" />
<meta name="author" content="Teng Jun" />


    
    


<meta name="description" content="hello,every body!~">
<meta property="og:type" content="website">
<meta property="og:title" content="嘟嘟独立博客">
<meta property="og:url" content="http://tengj.github.io/page/2/index.html">
<meta property="og:site_name" content="嘟嘟独立博客">
<meta property="og:description" content="hello,every body!~">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="嘟嘟独立博客">
<meta name="twitter:description" content="hello,every body!~">

<link rel="apple-touch-icon" href= "/apple-touch-icon.png">


    <link rel="alternate" href="/atom.xml" title="嘟嘟独立博客" type="application/atom+xml">



    <link rel="shortcut icon" href="/img/author.jpg">



    <link href="//cdn.bootcss.com/animate.css/3.5.1/animate.min.css" rel="stylesheet">



    <link href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" rel="stylesheet">



    <script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
    <link href="//cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-minimal.css" rel="stylesheet">


<link rel="stylesheet" href="/css/style.css" type="text/css">


    <style> .article { opacity: 0;} </style>


<link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">


<title>嘟嘟独立博客</title>

<script src="//cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script>
<script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"></script>

<script>
    var yiliaConfig = {
        fancybox: true,
        animate: true,
        isHome: true,
        isPost: false,
        isArchive: false,
        isTag: false,
        isCategory: false,
        fancybox_js: "//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js",
        scrollreveal: "//cdn.bootcss.com/scrollReveal.js/3.1.4/scrollreveal.min.js",
        search: true
    }
</script>


    <script>
        yiliaConfig.jquery_ui = [true, "//cdn.bootcss.com/jqueryui/1.10.4/jquery-ui.min.js", "//cdn.bootcss.com/jqueryui/1.10.4/css/jquery-ui.min.css"];
    </script>



    <script> yiliaConfig.rootUrl = "\/";</script>






</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic">
            <img src="/img/dudu.gif" class="animated zoomIn">
        </a>
        <hgroup>
          <h1 class="header-author"><a href="/">Teng Jun</a></h1>
        </hgroup>

        
        <p class="header-subtitle">爱生活爱编码</p>
        

        
            <form id="search-form">
            <input type="text" id="local-search-input" name="q" placeholder="search..." class="search form-control" autocomplete="off" autocorrect="off" searchonload="false" />
            <i class="fa fa-times" onclick="resetSearch()"></i>
            </form>
            <div id="local-search-result"></div>
            <p class='no-result'>No results found <i class='fa fa-spinner fa-pulse'></i></p>
        


        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        <div class="icon-wrap icon-link hide" data-idx="2">
                            <div class="loopback_l"></div>
                            <div class="loopback_r"></div>
                        </div>
                        
                        
                        <div class="icon-wrap icon-me hide" data-idx="3">
                            <div class="user"></div>
                            <div class="shoulder"></div>
                        </div>
                        
                    </div>
                    
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        <li>友情链接</li>
                        
                        
                        <li>关于我</li>
                        
                    </ul>
                </div>
            </div>
        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/">主页</a></li>
                        
                            <li><a href="/archives/">所有文章</a></li>
                        
                            <li><a href="/tags/">标签云</a></li>
                        
                            <li><a href="/about/">关于我</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" href="mailto:123@123.com" title="Email"></a>
                            
                                <a class="fa GitHub" href="/#" title="GitHub"></a>
                            
                                <a class="fa RSS" href="/atom.xml" title="RSS"></a>
                            
                        </ul>
                    </nav>
                </section>
                
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/IDEA/">IDEA</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SEO/">SEO</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring-Boot/">Spring Boot</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/">git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo/">hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/jQuery/">jQuery</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/">java</a></li></ul>
                    </div>
                </section>
                
                
                
                <section class="switch-part switch-part3">
                    <div id="js-friends">
                    
                      <a class="main-nav-link switch-friends-link" href="https://hexo.io">Hexo</a>
                    
                      <a class="main-nav-link switch-friends-link" href="https://pages.github.com/">GitHub</a>
                    
                      <a class="main-nav-link switch-friends-link" href="http://moxfive.xyz/">MOxFIVE</a>
                    
                    </div>
                </section>
                

                
                
                <section class="switch-part switch-part4">
                
                    <div id="js-aboutme">专注于前端</div>
                </section>
                
            </div>
        </div>
    </header>                
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">Teng Jun</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                <img src="/img/dudu.gif" class="animated zoomIn">
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页">Teng Jun</a></h1>
            </hgroup>
            
            <p class="header-subtitle">爱生活爱编码</p>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/">主页</a></li>
                
                    <li><a href="/archives/">所有文章</a></li>
                
                    <li><a href="/tags/">标签云</a></li>
                
                    <li><a href="/about/">关于我</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" target="_blank" href="mailto:123@123.com" title="Email"></a>
                            
                                <a class="fa GitHub" target="_blank" href="/#" title="GitHub"></a>
                            
                                <a class="fa RSS" target="_blank" href="/atom.xml" title="RSS"></a>
                            
                        </ul>
            </nav>
        </header>                
    </div>
    <link class="menu-list" tags="标签" friends="友情链接" about="关于我"/>
</nav>
      <div class="body-wrap">
  
    <article id="post-threadsynchronized2" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/05/03/threadsynchronized2/" class="article-date">
      <time datetime="2016-05-02T22:59:54.000Z" itemprop="datePublished">2016-05-03</time>
</a>

 
    <a href="/2016/05/03/threadsynchronized2/#comments" title="查看评论">
        <i class="fa fa-comments-o" aria-hidden="true"></i>
        <span class="count-comment"></span>
        
            <span class="ds-thread-count"  data-thread-key="2016/05/03/threadsynchronized2/" ></span>
        
        
    </a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/05/03/threadsynchronized2/">Java多线程干货系列—（二）synchronized</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本篇主要介绍Java多线程中的同步，也就是如何在Java语言中写出线程安全的程序，如何在Java语言中解决非线程安全的相关问题。没错就是使用synchronized。</p>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="如何解决线程安全问题？"><a href="#如何解决线程安全问题？" class="headerlink" title="如何解决线程安全问题？"></a>如何解决线程安全问题？</h2><p>那么一般来说，是如何解决线程安全问题的呢？</p>
<p>基本上所有的并发模式在解决线程安全问题时，都采用“序列化访问临界资源”的方案，即在同一时刻，只能有一个线程访问临界资源，也称作同步互斥访问。</p>
<p>通常来说，是在访问临界资源的代码前面加上一个锁，当访问完临界资源后释放锁，让其他线程继续访问。</p>
<p>在Java中，提供了两种方式来实现同步互斥访问：synchronized和Lock。</p>
<p>本文主要讲述synchronized的使用方法，Lock的使用方法在下一篇博文中讲述。</p>
<h2 id="synchronized同步方法"><a href="#synchronized同步方法" class="headerlink" title="synchronized同步方法"></a>synchronized同步方法</h2><p>synchronized是Java语言的关键字，当它用来修饰一个方法或者一个代码块的时候，能够保证在同一时刻最多只有一个线程执行该段代码。在了解synchronized关键字的使用方法之前，我们先来看一个概念：互斥锁，顾名思义：能到达到互斥访问目的的锁。</p>
<p>举个简单的例子：如果对临界资源加上互斥锁，当一个线程在访问该临界资源时，其他线程便只能等待。</p>
<p>在Java中，每一个对象都拥有一个锁标记（monitor），也称为监视器，多线程同时访问某个对象时，线程只有获取了该对象的锁才能访问。</p>
<p>在Java中，可以使用synchronized关键字来标记一个方法或者代码块，当某个线程调用该对象的synchronized方法或者访问synchronized代码块时，这个线程便获得了该对象的锁，其他线程暂时无法访问这个方法，只有等待这个方法执行完毕或者代码块执行完毕，这个线程才会释放该对象的锁，其他线程才能执行这个方法或者代码块。</p>
<h3 id="synchronized的使用"><a href="#synchronized的使用" class="headerlink" title="synchronized的使用"></a>synchronized的使用</h3><ul>
<li><p>synchronized代码块，被修饰的代码成为同步语句块，其作用的范围是调用这个代码块的对象，我们在用synchronized关键字的时候，能缩小代码段的范围就尽量缩小，能在代码段上加同步就不要再整个方法上加同步。这叫减小锁的粒度，使代码更大程度的并发。</p>
</li>
<li><p>synchronized方法，被修饰的方法成为同步方法，其作用范围是整个方法，作用对象是调用这个方法的对象。</p>
</li>
<li><p>synchronized静态方法，修饰一个static静态方法，其作用范围是整个静态方法，作用对象是这个类的所有对象。</p>
</li>
<li><p>synchronized类，其作用范围是Synchronized后面括号括起来的部分synchronized(className.class)，作用的对象是这个类的所有对象。</p>
</li>
<li><p>synchronized()，()中是锁住的对象， synchronized(this)锁住的只是对象本身，同一个类的不同对象调用的synchronized方法并不会被锁住，而synchronized(className.class)实现了全局锁的功能，所有这个类的对象调用这个方法都受到锁的影响，此外()中还可以添加一个具体的对象，实现给具体对象加锁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (object) &#123;</span><br><span class="line">  <span class="comment">//在同步代码块中对对象进行操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="synchronized注意事项"><a href="#synchronized注意事项" class="headerlink" title="synchronized注意事项"></a>synchronized注意事项</h1><ul>
<li><p>当两个并发线程访问同一个对象中的<code>synchronized</code>代码块时，在同一时刻只能有一个线程得到执行，另一个线程受阻塞，必须等待当前线程执行完这个代码块以后才能执行该代码块。两个线程间是互斥的，因为在执行<code>synchronized</code>代码块时会锁定当前的对象，只有执行完该代码块才能释放该对象锁，下一个线程才能执行并锁定该对象。</p>
</li>
<li><p>当一个线程访问<code>object</code>的一个<code>synchronized(this)</code>同步代码块时，另一个线程仍然可以访问该<code>object</code>中的非<code>synchronized(this)</code>同步代码块。(两个线程使用的是同一个对象)</p>
</li>
<li>当一个线程访问<code>object</code>的一个<code>synchronized(this)</code>同步代码块时，其他线程对<code>object</code>中所有其它<code>synchronized(this)</code>同步代码块的访问将被阻塞(同上，两个线程使用的是同一个对象)。</li>
</ul>
<p>下面通过代码来实现：</p>
<p>1）当两个并发线程访问同一个对象object中的这个synchronized(this)同步代码块时，一个时间内只能有一个线程得到执行。另一个线程必须等待当前线程执行完这个代码块以后才能执行该代码块。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ths;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread1</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;  </span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">          <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;  </span><br><span class="line">               <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;  </span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">" synchronized loop "</span> + i);  </span><br><span class="line">               &#125;  </span><br><span class="line">          &#125;  </span><br><span class="line">     &#125;  </span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">          Thread1 t1 = <span class="keyword">new</span> Thread1();  </span><br><span class="line">          Thread ta = <span class="keyword">new</span> Thread(t1, <span class="string">"A"</span>);  </span><br><span class="line">          Thread tb = <span class="keyword">new</span> Thread(t1, <span class="string">"B"</span>);  </span><br><span class="line">          ta.start();  </span><br><span class="line">          tb.start();  </span><br><span class="line">     &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">A <span class="keyword">synchronized</span> loop <span class="number">0</span>  </span><br><span class="line">A <span class="keyword">synchronized</span> loop <span class="number">1</span>  </span><br><span class="line">A <span class="keyword">synchronized</span> loop <span class="number">2</span>  </span><br><span class="line">A <span class="keyword">synchronized</span> loop <span class="number">3</span>  </span><br><span class="line">A <span class="keyword">synchronized</span> loop <span class="number">4</span>  </span><br><span class="line">B <span class="keyword">synchronized</span> loop <span class="number">0</span>  </span><br><span class="line">B <span class="keyword">synchronized</span> loop <span class="number">1</span>  </span><br><span class="line">B <span class="keyword">synchronized</span> loop <span class="number">2</span>  </span><br><span class="line">B <span class="keyword">synchronized</span> loop <span class="number">3</span>  </span><br><span class="line">B <span class="keyword">synchronized</span> loop <span class="number">4</span></span><br></pre></td></tr></table></figure></p>
<p>2）然而，当一个线程访问object的一个synchronized(this)同步代码块时，另一个线程仍然可以访问该object中的非synchronized(this)同步代码块。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ths;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread2</span> </span>&#123;  </span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m4t1</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">          <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;  </span><br><span class="line">               <span class="keyword">int</span> i = <span class="number">5</span>;  </span><br><span class="line">               <span class="keyword">while</span>( i-- &gt; <span class="number">0</span>) &#123;  </span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">" : "</span> + i);  </span><br><span class="line">                    <span class="keyword">try</span> &#123;  </span><br><span class="line">                         Thread.sleep(<span class="number">500</span>);  </span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;  </span><br><span class="line">                    &#125;  </span><br><span class="line">               &#125;  </span><br><span class="line">          &#125;  </span><br><span class="line">     &#125;  </span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m4t2</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">          <span class="keyword">int</span> i = <span class="number">5</span>;  </span><br><span class="line">          <span class="keyword">while</span>( i-- &gt; <span class="number">0</span>) &#123;  </span><br><span class="line">               System.out.println(Thread.currentThread().getName() + <span class="string">" : "</span> + i);  </span><br><span class="line">               <span class="keyword">try</span> &#123;  </span><br><span class="line">                    Thread.sleep(<span class="number">500</span>);  </span><br><span class="line">               &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;  </span><br><span class="line">               &#125;  </span><br><span class="line">          &#125;  </span><br><span class="line">     &#125;  </span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">          <span class="keyword">final</span> Thread2 myt2 = <span class="keyword">new</span> Thread2();  </span><br><span class="line">          Thread t1 = <span class="keyword">new</span> Thread(  <span class="keyword">new</span> Runnable() &#123;  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  myt2.m4t1();  &#125;  &#125;, <span class="string">"t1"</span>  );  </span><br><span class="line">          Thread t2 = <span class="keyword">new</span> Thread(  <span class="keyword">new</span> Runnable() &#123;  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; myt2.m4t2();   &#125;  &#125;, <span class="string">"t2"</span>  );  </span><br><span class="line">          t1.start();  </span><br><span class="line">          t2.start();  </span><br><span class="line">     &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">t1 : <span class="number">4</span>  </span><br><span class="line">t2 : <span class="number">4</span>  </span><br><span class="line">t1 : <span class="number">3</span>  </span><br><span class="line">t2 : <span class="number">3</span>  </span><br><span class="line">t1 : <span class="number">2</span>  </span><br><span class="line">t2 : <span class="number">2</span>  </span><br><span class="line">t1 : <span class="number">1</span>  </span><br><span class="line">t2 : <span class="number">1</span>  </span><br><span class="line">t1 : <span class="number">0</span>  </span><br><span class="line">t2 : <span class="number">0</span></span><br></pre></td></tr></table></figure></p>
<p>3)尤其关键的是，当一个线程访问object的一个synchronized(this)同步代码块时，其他线程对object中所有其它synchronized(this)同步代码块的访问将被阻塞。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//修改Thread2.m4t2()方法：  </span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m4t2</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">          <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;  </span><br><span class="line">               <span class="keyword">int</span> i = <span class="number">5</span>;  </span><br><span class="line">               <span class="keyword">while</span>( i-- &gt; <span class="number">0</span>) &#123;  </span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">" : "</span> + i);  </span><br><span class="line">                    <span class="keyword">try</span> &#123;  </span><br><span class="line">                         Thread.sleep(<span class="number">500</span>);  </span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;  </span><br><span class="line">                    &#125;  </span><br><span class="line">               &#125;  </span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure></p>
<p>输出结果:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">t1 : <span class="number">4</span>  </span><br><span class="line">t1 : <span class="number">3</span>  </span><br><span class="line">t1 : <span class="number">2</span>  </span><br><span class="line">t1 : <span class="number">1</span>  </span><br><span class="line">t1 : <span class="number">0</span>  </span><br><span class="line">t2 : <span class="number">4</span>  </span><br><span class="line">t2 : <span class="number">3</span>  </span><br><span class="line">t2 : <span class="number">2</span>  </span><br><span class="line">t2 : <span class="number">1</span>  </span><br><span class="line">t2 : <span class="number">0</span></span><br></pre></td></tr></table></figure></p>
<p>4)第三个例子同样适用其它同步代码块。也就是说，当一个线程访问object的一个synchronized(this)同步代码块时，它就获得了这个object的对象锁。结果，其它线程对该object对象所有同步代码部分的访问都被暂时阻塞。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//修改Thread2.m4t2()方法如下：</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">m4t2</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">         <span class="keyword">int</span> i = <span class="number">5</span>;  </span><br><span class="line">         <span class="keyword">while</span>( i-- &gt; <span class="number">0</span>) &#123;  </span><br><span class="line">              System.out.println(Thread.currentThread().getName() + <span class="string">" : "</span> + i);  </span><br><span class="line">              <span class="keyword">try</span> &#123;  </span><br><span class="line">                   Thread.sleep(<span class="number">500</span>);  </span><br><span class="line">              &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;  </span><br><span class="line">              &#125;  </span><br><span class="line">         &#125;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>输出结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">t1 : <span class="number">4</span>  </span><br><span class="line">t1 : <span class="number">3</span>  </span><br><span class="line">t1 : <span class="number">2</span>  </span><br><span class="line">t1 : <span class="number">1</span>  </span><br><span class="line">t1 : <span class="number">0</span>  </span><br><span class="line">t2 : <span class="number">4</span>  </span><br><span class="line">t2 : <span class="number">3</span>  </span><br><span class="line">t2 : <span class="number">2</span>  </span><br><span class="line">t2 : <span class="number">1</span>  </span><br><span class="line">t2 : <span class="number">0</span></span><br></pre></td></tr></table></figure></p>
<p>5)每个类也会有一个锁，它可以用来控制对static数据成员的并发访问。<br>并且如果一个线程执行一个对象的非static synchronized方法，另外一个线程需要执行这个对象所属类的static synchronized方法，此时不会发生互斥现象，因为访问static synchronized方法占用的是类锁，而访问非static synchronized方法占用的是对象锁，所以不存在互斥现象。<br>代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> InsertData insertData = <span class="keyword">new</span> InsertData();</span><br><span class="line">        <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="annotation">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                insertData.insert();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start(); </span><br><span class="line">        <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="annotation">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                insertData.insert1();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InsertData</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"执行insert"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"执行insert完毕"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insert1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"执行insert1"</span>);</span><br><span class="line">        System.out.println(<span class="string">"执行insert1完毕"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">执行insert</span><br><span class="line">执行insert1</span><br><span class="line">执行insert1完毕</span><br><span class="line">执行insert完毕</span><br></pre></td></tr></table></figure></p>
<p>第一个线程里面执行的是insert方法，不会导致第二个线程执行insert1方法发生阻塞现象。</p>
<h1 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h1><p><strong>当一个线程进入一个对象的synchronized方法A之后，其它线程是否可进入此对象的synchronized方法B？</strong><br>答：不能。其它线程只能访问该对象的非同步方法，同步方法则不能进入。因为非静态方法上的synchronized修饰符要求执行方法时要获得对象的锁，如果已经进入A方法说明对象锁已经被取走，那么试图进入B方法的线程就只能在等锁池（<strong>注意不是等待池哦</strong>）中等待对象的锁。</p>
<p><strong>synchronized关键字的用法？</strong><br>答：synchronized关键字可以将对象或者方法标记为同步，以实现对对象和方法的互斥访问，可以用synchronized(对象) { … }定义同步代码块，或者在声明方法时将synchronized作为方法的修饰符。</p>
<p><strong>简述synchronized 和java.util.concurrent.locks.Lock的异同？</strong><br>答：Lock是Java 5以后引入的新的API，和关键字synchronized相比主要相同点：Lock 能完成synchronized所实现的所有功能；主要不同点：Lock有比synchronized更精确的线程语义和更好的性能，而且不强制性的要求一定要获得锁。synchronized会自动释放锁，而Lock一定要求程序员手工释放，并且最好在finally 块中释放（这是释放外部资源的最好的地方）</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>以上就是<strong>synchronized</strong>的概念和基本使用用法，下一篇博文中将介绍Lock，希望对你有所帮助。</p>
<hr>
<p>一直觉得自己写的不是技术，而是情怀，一篇篇文章是自己这一路走来的痕迹。靠专业技能的成功是最具可复制性的，希望我的这条路能让你少走弯路，希望我能帮你抹去知识的蒙尘，希望我能帮你理清知识的脉络，希望未来技术之巅上有你也有我。</p>
<hr>
<p> 博主弄了个java学习资源的公众号，学习资源超级多，视频，电子书，最新开发工具一个都不能少，已全部分享到百度云盘，求资源共享，打造一个学习方便，工作方便的java公众号，开源开源，有需求的可以关注~撒花<br> <img src="http://7xqch5.com1.z0.glb.clouddn.com/javaLearn.PNG" alt=""></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Java多线程/">Java多线程</a>
    </div>


      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-springmvctotal" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/05/02/springmvctotal/" class="article-date">
      <time datetime="2016-05-02T10:31:57.000Z" itemprop="datePublished">2016-05-02</time>
</a>

 
    <a href="/2016/05/02/springmvctotal/#comments" title="查看评论">
        <i class="fa fa-comments-o" aria-hidden="true"></i>
        <span class="count-comment"></span>
        
            <span class="ds-thread-count"  data-thread-key="2016/05/02/springmvctotal/" ></span>
        
        
    </a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/05/02/springmvctotal/">springMVC干货系列：从零搭建springMVC+mybatis（总纲）</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h1 id="首页"><a href="#首页" class="headerlink" title="首页"></a>首页</h1><p>最近一段时间有个公司项目需求调研后，项目组决定使用springMVC+mybatis3+bootstrap来实现。<br>于是总结一下最近使用的心得，以及开发过程中遇到的问题。</p>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>SpringMVC是Java开发人员必须要掌握的一个框架，掌握它能令你工作上如鱼得水。<br>本系列会从零开始教你如何搭建springMVC的项目，包含spring注解，mybatis,日志系统，事务，多数据源，单元测试等居多功能。<br>让新手也能一步到位：搭建起来现在比较流行的框架<br>开发环境：<br>IED:myeclipse2014<br>jdk:1.7<br>tomcat:7<br>springmvc:4<br>mybatis: 3.3<br>junit: 4.11</p>
<h2 id="后期该系列博文目录如下"><a href="#后期该系列博文目录如下" class="headerlink" title="后期该系列博文目录如下"></a>后期该系列博文目录如下</h2><p><a href="http://tengj.top/2016/03/13/springmvcseries1/" target="_blank" rel="external">从零搭建SpringMVC+mybatis（一）：maven WEB 项目的搭建</a><br><a href="http://tengj.top/2016/05/02/springmvcyuanli/" target="_blank" rel="external">从零搭建SpringMVC+mybatis（二）：SpringMVC原理解析及常用注解</a><br><a href="http://tengj.top/2016/05/02/springmvc3iocdi/" target="_blank" rel="external">从零搭建SpringMVC+mybatis（三）：Spring两大核心之IOC/DI学习</a><br><a href="http://tengj.top/2016/05/12/springmvc4aop/" target="_blank" rel="external">从零搭建SpringMVC+mybatis（四）：Spring两大核心之AOP学习</a><br>从零搭建SpringMVC+mybatis（五）：SpringMVC整合mybatis<br>从零搭建SpringMVC+mybatis（六）：SpringMVC中日志系统log4j的配置<br>从零搭建SpringMVC+mybatis（七）：基于注解的事务配置，多数据源切换<br>从零搭建SpringMVC+mybatis（八）：SpringMVC使用Junit4单元测试<br>从零搭建SpringMVC+mybatis（九）：SpringMVC中定时任务的配置 (Quartz &amp; spring-task)<br>从零搭建SpringMVC+mybatis（十）： SpringMVC中 安全机制<br>从零搭建SpringMVC+mybatis（十一）： SpringMVC中 缓存实现方式  </p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>希望自己能坚持写下去，整理出一套入门简单的教程。</p>
<hr>
<p> 博主弄了个java学习资源的公众号，学习资源超级多，视频，电子书，最新开发工具一个都不能少，已全部分享到百度云盘，求资源共享，打造一个学习方便，工作方便的java公众号，开源开源，有需求的可以关注~撒花<br> <img src="http://7xqch5.com1.z0.glb.clouddn.com/javaLearn.PNG" alt=""></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/springMVC/">springMVC</a>
    </div>


      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-springmvc3iocdi" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/05/02/springmvc3iocdi/" class="article-date">
      <time datetime="2016-05-02T10:21:16.000Z" itemprop="datePublished">2016-05-02</time>
</a>

 
    <a href="/2016/05/02/springmvc3iocdi/#comments" title="查看评论">
        <i class="fa fa-comments-o" aria-hidden="true"></i>
        <span class="count-comment"></span>
        
            <span class="ds-thread-count"  data-thread-key="2016/05/02/springmvc3iocdi/" ></span>
        
        
    </a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/05/02/springmvc3iocdi/">springMVC干货系列：从零搭建springMVC+mybatis（三）：spring两大核心之IOC/DI学习</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>上篇讲了SpringMVC的实现原理以及常用的注解，其实里面都用到的spring的核心概念，那就是IOC/DI，今天给大家介绍下这核心概念IOC/DI。</p>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>分享Iteye的开涛这位技术牛人对Spring框架的IOC的理解,写得非常通俗易懂。</p>
<h2 id="IoC是什么"><a href="#IoC是什么" class="headerlink" title="IoC是什么"></a>IoC是什么</h2><p>Ioc—Inversion of Control，即“控制反转”，不是什么技术，而是一种设计思想。在Java开发中，Ioc意味着将你设计好的对象交给容器控制，而不是传统的在你的对象内部直接控制。如何理解好Ioc呢？理解好Ioc的关键是要明确“谁控制谁，控制什么，为何是反转（有反转就应该有正转了），哪些方面反转了”，那我们来深入分析一下：</p>
<ul>
<li><p>谁控制谁，控制什么：传统Java SE程序设计，我们直接在对象内部通过new进行创建对象，是程序主动去创建依赖对象；而IoC是有专门一个容器来创建这些对象，即由Ioc容器来控制对 象的创建；谁控制谁？当然是IoC 容器控制了对象；控制什么？那就是主要控制了外部资源获取（不只是对象包括比如文件等）。</p>
</li>
<li><p>为何是反转，哪些方面反转了：有反转就有正转，传统应用程序是由我们自己在对象中主动控制去直接获取依赖对象，也就是正转；而反转则是由容器来帮忙创建及注入依赖对象；为何是反转？因为由容器帮我们查找及注入依赖对象，对象只是被动的接受依赖对象，所以是反转；哪些方面反转了？依赖对象的获取被反转了。</p>
</li>
</ul>
<p>用图例说明一下，传统程序设计如图2-1，都是主动去创建相关对象然后再组合起来：<br><img src="http://7xqch5.com1.z0.glb.clouddn.com/springmvc3_2.jpg" alt=""></p>
<p>当有了IoC/DI的容器后，在客户端类中不再主动去创建这些对象了，如图所示:<br><img src="http://7xqch5.com1.z0.glb.clouddn.com/springmvc3_3.png" alt="">  </p>
<h2 id="IoC能做什么"><a href="#IoC能做什么" class="headerlink" title="IoC能做什么"></a>IoC能做什么</h2><p>IoC 不是一种技术，只是一种思想，一个重要的面向对象编程的法则，它能指导我们如何设计出松耦合、更优良的程序。传统应用程序都是由我们在类内部主动创建依赖对象，从而导致类与类之间高耦合，难于测试；有了IoC容器后，把创建和查找依赖对象的控制权交给了容器，由容器进行注入组合对象，所以对象与对象之间是 松散耦合，这样也方便测试，利于功能复用，更重要的是使得程序的整个体系结构变得非常灵活。</p>
<p>其实IoC对编程带来的最大改变不是从代码上，而是从思想上，发生了“主从换位”的变化。应用程序原本是老大，要获取什么资源都是主动出击，但是在IoC/DI思想中，应用程序就变成被动的了，被动的等待IoC容器来创建并注入它所需要的资源了。</p>
<p>IoC很好的体现了面向对象设计法则之一—— 好莱坞法则：“别找我们，我们找你”；即由IoC容器帮对象找相应的依赖对象并注入，而不是由对象主动去找。</p>
<h2 id="IoC和DI"><a href="#IoC和DI" class="headerlink" title="IoC和DI"></a>IoC和DI</h2><p> DI—Dependency Injection，即“依赖注入”：组件之间依赖关系由容器在运行期决定，形象的说，即由容器动态的将某个依赖关系注入到组件之中。依赖注入的目的并非为软件系统带来更多功能，而是为了提升组件重用的频率，并为系统搭建一个灵活、可扩展的平台。通过依赖注入机制，我们只需要通过简单的配置，而无需任何代码就可指定目标需要的资源，完成自身的业务逻辑，而不需要关心具体的资源来自何处，由谁实现。</p>
<p>理解DI的关键是：“谁依赖谁，为什么需要依赖，谁注入谁，注入了什么”，那我们来深入分析一下：</p>
<ul>
<li><p>谁依赖于谁：当然是应用程序依赖于IoC容器；</p>
</li>
<li><p>为什么需要依赖：应用程序需要IoC容器来提供对象需要的外部资源；</p>
</li>
<li><p>谁注入谁：很明显是IoC容器注入应用程序某个对象，应用程序依赖的对象；</p>
</li>
<li><p>注入了什么：就是注入某个对象所需要的外部资源（包括对象、资源、常量数据）。</p>
</li>
</ul>
<p>IoC和DI由什么关系呢？其实它们是同一个概念的不同角度描述，由于控制反转概念比较含糊（可能只是理解为容器控制对象这一个层面，很难让人想到谁来维护对象关系），所以2004年大师级人物Martin Fowler又给出了一个新的名字：“依赖注入”，相对IoC 而言，“依赖注入”明确描述了“被注入对象依赖IoC容器配置依赖对象”。</p>
<p>看过很多对Spring的Ioc理解的文章，好多人对Ioc和DI的解释都晦涩难懂，反正就是一种说不清，道不明的感觉，读完之后依然是一头雾水，感觉就是开涛这位技术牛人写得特别通俗易懂，他清楚地解释了IoC(控制反转) 和DI(依赖注入)中的每一个字，读完之后给人一种豁然开朗的感觉。我相信对于初学Spring框架的人对Ioc的理解应该是有很大帮助的。</p>
<h2 id="Spring配置的可选方案"><a href="#Spring配置的可选方案" class="headerlink" title="Spring配置的可选方案"></a>Spring配置的可选方案</h2><p>上面介绍了IOC跟DI的概念，接着，我将归纳一下使用Spring装备bean的基础知识，因为DI是Spring的最基本要素。所以在开发的基于Spring的应用时，我们随时都在使用这些技术。<br>当描述bean如何进行装配时，Spring具有非常大的灵活性，它提供了三种主要的装配机制：  </p>
<ul>
<li>在XML中进行显示配置</li>
<li>在Java中进行显示配置</li>
<li>隐式的bean发现机制和自动装配</li>
</ul>
<p>虽然看上去提供三种可选的配置方案会使Spring变得复杂。其实，你可以根据实际项目选择，对了，上面这三种其实可以混合搭配，目前博主使用的就是自动装配（也就是注解）+XML混合使用。这也是目前比较流行的方式。</p>
<p>下面将主要介绍自动化装备Bean+XML的混合搭配</p>
<h2 id="自动化装配bean"><a href="#自动化装配bean" class="headerlink" title="自动化装配bean"></a>自动化装配bean</h2><p>当前来说，相比较前面两种显示配置，从便利性方面来看，最强大的还是Spring的自动化配置。<br>Spring从两个角度来实现自动化装配：  </p>
<ul>
<li>组件扫描（component scanning）:Spring会自动发现应用上下文中所创建的bean</li>
<li>自动装配（autowiring）：Spring自动满足bean之间的依赖</li>
</ul>
<p>组件扫描和自动装配组合在一起就能发挥出强大的威力，他们能够将你的显示配置降低到最少。</p>
<p>这里组件扫描我们通过在XML里面使用Spring context命名空间的<context:component-scan>元素来启用。<br>配置如下：  </context:component-scan></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 加了下面2局就可以直接使用spring注解 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 自动扫描的包名 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">context:component-scan</span> <span class="attribute">base-package</span>=<span class="value">"com.tengj.demo"</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 默认的注解映射的支持 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">mvc:annotation-driven</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>context:component-scan里面的 base-package指明了被扫描的包的路径是在com.tengj.demo下面的所有类  </p>
<p>其中mvc:annotation-driven 是开启默认的注解映射的支持，这样就能认到被使用的注解。<br>我们在com.tengj.demo下面创建一个UserController控制类：  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span></span>&#123;</span><br><span class="line">    <span class="annotation">@Autowired</span></span><br><span class="line">	UserService userService;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>UserService是我们的一个接口，代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addUser</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>UserServiceImpl是UserService的实现类：  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Service</span>(<span class="string">"userService"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span></span>&#123;</span><br><span class="line"><span class="annotation">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addUser</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"新增用户"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>写个单元测试类来验证这个userService是否已经自动注入了  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@RunWith</span>(SpringJUnit4ClassRunner.class)</span><br><span class="line"><span class="annotation">@ContextConfiguration</span>(&#123;<span class="string">"classpath:spring/applicationContext.xml"</span>&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserConTrollerTest</span> </span>&#123;</span><br><span class="line">	<span class="annotation">@Autowired</span></span><br><span class="line">	UserService userService;</span><br><span class="line">	</span><br><span class="line">	<span class="annotation">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkServiceIsNull</span><span class="params">()</span></span>&#123;</span><br><span class="line">		Assert.assertNotNull(userService);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>UserConTrollerTest使用了Spring的SpringJUnit4ClassRunner，以便在测试开始的时候自动创建Spring的应用上下文，注解@ContextConfiguration会告诉它需要在UserConTrollerTest中加载配置。所以读取applicationContext.xml配置文件，配置文件里面有<context:component-scan base-package="com.tengj.demo">这个启用自动扫描的元素。  </context:component-scan></p>
<p>为了证明这一点，在测试代码中有一个UserService类型的属性，并且这个属性带有@Autowired注解，以便于将UserService bean注入到测试代码之中。最后，会有一个简单的测试方法断言userService属性不为null。如果它不为null的话，就意味着Spring能够发现UserService类，自动在Spring上下文中将其创建为bean并将其注入到测试代码之中。  </p>
<p>在代码中右键执行Junit Test，如果执行如下是绿色的就表示成功。  </p>
<p><img src="http://7xqch5.com1.z0.glb.clouddn.com/springmvc3_1.png" alt=""></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这就是一个简单的DI注入测试，是不是觉得很方便，要注入什么属性只要定义一下属性。剩下都交给Spring容器来搞定。Junit单元测试写法后续会专门写一篇来介绍，这也是非常重要的一个验证自己所写代码是否正确的手段。</p>
<hr>
<p>一直觉得自己写的不是技术，而是情怀，一篇篇文章是自己这一路走来的痕迹。靠专业技能的成功是最具可复制性的，希望我的这条路能让你少走弯路，希望我能帮你抹去知识的蒙尘，希望我能帮你理清知识的脉络，希望未来技术之巅上有你也有我。</p>
<hr>
<p> 博主弄了个java学习资源的公众号，学习资源超级多，视频，电子书，最新开发工具一个都不能少，已全部分享到百度云盘，求资源共享，打造一个学习方便，工作方便的java公众号，开源开源，有需求的可以关注~撒花<br> <img src="http://7xqch5.com1.z0.glb.clouddn.com/javaLearn.PNG" alt=""></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/springMVC/">springMVC</a>
    </div>


      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-springmvcyuanli" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/05/02/springmvcyuanli/" class="article-date">
      <time datetime="2016-05-01T22:38:27.000Z" itemprop="datePublished">2016-05-02</time>
</a>

 
    <a href="/2016/05/02/springmvcyuanli/#comments" title="查看评论">
        <i class="fa fa-comments-o" aria-hidden="true"></i>
        <span class="count-comment"></span>
        
            <span class="ds-thread-count"  data-thread-key="2016/05/02/springmvcyuanli/" ></span>
        
        
    </a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/05/02/springmvcyuanli/">springMVC干货系列：从零搭建springMVC+mybatis（二）：springMVC原理解析及常用注解</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>上篇文章介绍了maven WEB 项目的搭建，基本的配置文件也都贴出来了，今天就来介绍下SpringMVC的工作原理以及工作中常用的注解。为以后开发打下坚实的基础。</p>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="SpringMVC框架介绍"><a href="#SpringMVC框架介绍" class="headerlink" title="SpringMVC框架介绍"></a>SpringMVC框架介绍</h2><p>SpringMVC就是通过DispatcherServlet将一堆组件串联起来的Web框架。</p>
<ul>
<li>Spring MVC属于SpringFrameWork的后续产品，已经融合在Spring Web Flow里面。</li>
</ul>
<blockquote>
<p>Spring 框架提供了构建 Web 应用程序的全功能 MVC 模块。使用 Spring 可插入的 MVC 架构，可以选择是使用内置的 Spring Web 框架还是 Struts 这样的 Web 框架。通过策略接口，Spring 框架是高度可配置的，而且包含多种视图技术，例如 JavaServer Pages（JSP）技术、Velocity、Tiles、iText 和 POI。Spring MVC 框架并不知道使用的视图，所以不会强迫您只使用 JSP 技术。<br>Spring MVC 分离了控制器、模型对象、分派器以及处理程序对象的角色，这种分离让它们更容易进行定制</p>
</blockquote>
<ul>
<li>Spring的MVC框架主要由DispatcherServlet、处理器映射、处理器(控制器)、视图解析器、视图组成。</li>
</ul>
<h2 id="SpringMVC原理图"><a href="#SpringMVC原理图" class="headerlink" title="SpringMVC原理图"></a>SpringMVC原理图</h2><p><img src="http://7xqch5.com1.z0.glb.clouddn.com/springmvc2_1.jpg" alt=""></p>
<h2 id="SpringMVC接口解释"><a href="#SpringMVC接口解释" class="headerlink" title="SpringMVC接口解释"></a>SpringMVC接口解释</h2><p><strong>DispatcherServlet接口</strong>：<br>Spring提供的前端控制器，所有的请求都有经过它来统一分发。在DispatcherServlet将请求分发给Spring Controller之前，需要借助于Spring提供的HandlerMapping定位到具体的Controller。</p>
<p><strong>HandlerMapping接口：</strong><br>能够完成客户请求到Controller映射。</p>
<p><strong>Controller接口：</strong><br>需要为并发用户处理上述请求，因此实现Controller接口时，必须保证线程安全并且可重用。</p>
<p>Controller将处理用户请求，这和Struts Action扮演的角色是一致的。一旦Controller处理完用户请求，则返回ModelAndView对象给DispatcherServlet前端控制器，ModelAndView中包含了模型（Model）和视图（View）。</p>
<p>从宏观角度考虑，DispatcherServlet是整个Web应用的控制器；从微观考虑，Controller是单个Http请求处理过程中的控制器，而ModelAndView是Http请求过程中返回的模型（Model）和视图（View）。</p>
<p><strong>ViewResolver接口：</strong><br>Spring提供的视图解析器（ViewResolver）在Web应用中查找View对象，从而将相应结果渲染给客户。</p>
<h2 id="SpringMVC运行原理"><a href="#SpringMVC运行原理" class="headerlink" title="SpringMVC运行原理"></a>SpringMVC运行原理</h2><ol>
<li><p>客户端请求提交到DispatcherServlet</p>
</li>
<li><p>由DispatcherServlet控制器查询一个或多个HandlerMapping，找到处理请求的Controller</p>
</li>
<li><p>DispatcherServlet将请求提交到Controller</p>
</li>
<li><p>Controller调用业务逻辑处理后，返回ModelAndView</p>
</li>
<li><p>DispatcherServlet查询一个或多个ViewResoler视图解析器，找到ModelAndView指定的视图</p>
</li>
<li><p>视图负责将结果显示到客户端</p>
</li>
</ol>
<p>DispatcherServlet是整个Spring MVC的核心。它负责接收HTTP请求组织协调Spring MVC的各个组成部分。其主要工作有以下三项：</p>
<ol>
<li>截获符合特定格式的URL请求。</li>
<li>初始化DispatcherServlet上下文对应的WebApplicationContext，并将其与业务层、持久化层的WebApplicationContext建立关联。</li>
<li>初始化Spring MVC的各个组成组件，并装配到DispatcherServlet中。</li>
</ol>
<p>结合项目理解:<br>1.大家由上面原理也看明白了，DispatcherServlet是整个Spring MVC的核心，SpringMVC所有的请求都会通过这个前端控制器。它配置的地方是在web.xml里面，配置如下：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">servlet-name</span>&gt;</span>springmvctouchbaidu<span class="tag">&lt;/<span class="title">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="title">servlet-class</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="title">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">param-value</span>&gt;</span>classpath:spring/applicationContext.xml<span class="tag">&lt;/<span class="title">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="title">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="title">load-on-startup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">servlet</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>配置的时候还指明了contextConfigLocation，这样就会去加载这个applicationContext.xml了。</p>
<p>2.原理第2点中由DispatcherServlet控制器查询一个或多个HandlerMapping，找到处理请求的Controller。这里其实是通过在applicationContext-mvc.xml配置了扫描路径以及开启了注解驱动来实现的。<br>applicationContext-mvc.xml中的配置：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">context:component-scan</span> <span class="attribute">base-package</span>=<span class="value">"com.tengj.demo"</span>/&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>context:component-scan说明了要扫描com.tengj.demo这个包下所有的类。这里要注意一下，大家以后开发中有用到注解的类一定都要在这个demo包下，不然就会抛异常的。</p>
<p>加载了扫描路径后，还要开启注解驱动，这样才能认到代码中使用到的注解，比如@Controller这个注解。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">mvc:annotation-driven</span> /&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>3.ViewResoler视图解析器对应配置里面的<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">bean</span> <span class="attribute">class</span>=<span class="value">"org.springframework.web.servlet.view.InternalResourceViewResolver"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"prefix"</span> <span class="attribute">value</span>=<span class="value">"/WEB-INF/pages/"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"suffix"</span> <span class="attribute">value</span>=<span class="value">".jsp"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>这样，当controller中方法返回的是<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="string">"index"</span>;</span><br></pre></td></tr></table></figure></p>
<p>的时候，实际是指向了/WEB-INF/pages/index.jsp这个页面。</p>
<h2 id="常用到的注解"><a href="#常用到的注解" class="headerlink" title="常用到的注解"></a>常用到的注解</h2><p>当我们使用了自动扫描+注解的方式后，就不需要在applicationContext-mvc.xml里面配置类的bean了，要引用类直接在成员变量上面加行注解，set/get方法也省了。超级方便，下面就列出常规开发中常用的注解。</p>
<h3 id="Component"><a href="#Component" class="headerlink" title="@Component"></a>@Component</h3><p>@Component<br>是所有受Spring 管理组件的通用形式，@Component注解可以放在类的头上，@Component不推荐使用。</p>
<h3 id="使用-Controller定义一个Controller控制器"><a href="#使用-Controller定义一个Controller控制器" class="headerlink" title="使用@Controller定义一个Controller控制器"></a>使用@Controller定义一个Controller控制器</h3><p>@Controller对应表现层的Bean，也就是Action，例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"> ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用@Controller注解标识UserController之后，就表示要把UserController交给Spring容器管理，在Spring容器中会存在一个名字为”userController”的action，这个名字是根据UserController类名来取的。注意：如果@Controller不指定其value【@Controller】，则默认的bean名字为这个类的类名首字母小写，如果指定value【@Controller(value=”UserController”)】或者【@Controller(“UserController”)】，则使用value作为bean的名字。</p>
<h3 id="使用-Service定义一个业务层Bean"><a href="#使用-Service定义一个业务层Bean" class="headerlink" title="使用@Service定义一个业务层Bean"></a>使用@Service定义一个业务层Bean</h3><p>@Service对应的是业务层Bean，例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Service</span>(<span class="string">"userService"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span></span>&#123;</span><br><span class="line">………</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>@Service(“userService”)注解是告诉Spring，当Spring要创建UserServiceImpl的的实例时，bean的名字必须叫做”userService”，这样当Action需要使用UserServiceImpl的的实例时,就可以由Spring创建好的”userService”，然后注入给Action：在Action只需要声明一个名字叫“userService”的变量来接收由Spring注入的”userService”即可，具体代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注入userService</span></span><br><span class="line"><span class="annotation">@Resource</span>(name=<span class="string">"userService"</span>)</span><br><span class="line">UserService userService;</span><br></pre></td></tr></table></figure></p>
<p>注意：在UserController声明的“userService”变量的类型必须是“UserServiceImpl”或者是其父类“UserService”，否则由于类型不一致而无法注入，由于UserController中的声明的“userService”变量使用了@Resource注解去标注，并且指明了其name = “userService”，这就等于告诉Spring，说我UserController要实例化一个“userService”，你Spring快点帮我实例化好，然后给我，当Spring看到userService变量上的@Resource的注解时，根据其指明的name属性可以知道，UserController中需要用到一个UserServiceImpl的实例，此时Spring就会把自己创建好的名字叫做”userService”的UserServiceImpl的实例注入给UserController中的“userService”变量，帮助UserController完成userService的实例化，这样在UserController中就不用通过“UserService userService = new UserServiceImpl();”这种最原始的方式去实例化userService了。  </p>
<p>如果没有Spring，那么当UserController需要使用UserServiceImpl时，必须通过“UserService userService = new UserServiceImpl();”主动去创建实例对象，但使用了Spring之后，UserController要使用UserServiceImpl时，就不用主动去创建UserServiceImpl的实例了，创建UserServiceImpl实例已经交给Spring来做了，Spring把创建好的UserServiceImpl实例给UserController，UserController拿到就可以直接用了。  </p>
<p>UserController由原来的主动创建UserServiceImpl实例后就可以马上使用，变成了被动等待由Spring创建好UserServiceImpl实例之后再注入给UserController，UserController才能够使用。这说明UserController对“UserServiceImpl”类的“控制权”已经被“反转”了，原来主动权在自己手上，自己要使用“UserServiceImpl”类的实例，自己主动去new一个出来马上就可以使用了，但现在自己不能主动去new“UserServiceImpl”类的实例，new“UserServiceImpl”类的实例的权力已经被Spring拿走了，只有Spring才能够new“UserServiceImpl”类的实例，而UserController只能等Spring创建好“UserServiceImpl”类的实例后，再“恳求”Spring把创建好的“UserServiceImpl”类的实例给他，这样他才能够使用“UserServiceImpl”，这就是Spring核心思想“控制反转”，也叫“依赖注入”。 </p>
<p>“依赖注入”也很好理解，UserController需要使用UserServiceImpl干活，那么就是对UserServiceImpl产生了依赖，Spring把Acion需要依赖的UserServiceImpl注入(也就是“给”)给UserController，这就是所谓的“依赖注入”。对UserController而言，UserController依赖什么东西，就请求Spring注入给他，对Spring而言，UserController需要什么，Spring就主动注入给他。</p>
<h3 id="使用-Repository定义一个数据访问层Bean"><a href="#使用-Repository定义一个数据访问层Bean" class="headerlink" title="使用@Repository定义一个数据访问层Bean"></a>使用@Repository定义一个数据访问层Bean</h3><p>@Repository对应数据访问层Bean ，例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Repository</span>(value=<span class="string">"userDao"</span>)</span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line"> ………</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>@Repository(value=”userDao”)注解是告诉Spring，让Spring创建一个名字叫“userDao”的UserDao实例。</p>
<p>当Service需要使用Spring创建的名字叫“userDao”的UserDao实例时，就可以使用@Resource(name = “userDao”)注解告诉Spring，Spring把创建好的userDao注入给Service即可。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注入userDao</span></span><br><span class="line"><span class="annotation">@Resource</span>(name = <span class="string">"userDao"</span>)</span><br><span class="line"><span class="keyword">private</span> UserDao userDao;</span><br></pre></td></tr></table></figure></p>
<h3 id="Resource跟-Autowired比较"><a href="#Resource跟-Autowired比较" class="headerlink" title="@Resource跟@Autowired比较"></a>@Resource跟@Autowired比较</h3><p>上面介绍中Controller中注入userService或者 Service层里面注入dao都是用@Resource标签，其实也可以使用@Autowired来替代，但是建议使用@Resource。下面说说这2者的区别：</p>
<ol>
<li>@Autowired和@Resource都可以用来装配bean，都可以写在字段上，或者方法上。</li>
<li>@Autowired属于Spring的；@Resource为JSR-250标准的注释，属于J2EE的。</li>
<li><p>@Autowired默认按类型装配，默认情况下必须要求依赖对象必须存在，如果要允许null值，可以设置它的required属性为false，例如：@Autowired(required=false) ，如果我们想使用名称装配可以结合@Qualifier注解进行使用<br>例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Autowired</span></span><br><span class="line"><span class="annotation">@Qualifier</span>(<span class="string">"baseDao"</span>)</span><br><span class="line"><span class="keyword">private</span> BaseDao baseDao;</span><br></pre></td></tr></table></figure>
</li>
<li><p>@Resource，默认按照名称进行装配，名称可以通过name属性进行指定，如果没有指定name属性，当注解写在字段上时，默认取字段名进行安装名称查找，如果注解写在setter方法上默认取属性名进行装配。当找不到与名称匹配的bean时才按照类型进行装配。但是需要注意的是，如果name属性一旦指定，就只会按照名称进行装配。<br>例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Resource</span>(name=<span class="string">"baseDao"</span>)</span><br><span class="line"><span class="keyword">private</span> BaseDao baseDao;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>5.之所以推荐使用@Resource，因为这个注解是属于J2EE的，减少了与spring的耦合。这样代码看起就比较优雅。</p>
<h3 id="使用-RequestMapping来映射Request请求与处理器"><a href="#使用-RequestMapping来映射Request请求与处理器" class="headerlink" title="使用@RequestMapping来映射Request请求与处理器"></a>使用@RequestMapping来映射Request请求与处理器</h3><p>SpringMVC使用@RequestMapping注解为控制器制定可以处理哪些URL请求<br>在控制器的类定义及方法定义处都可以标注</p>
<ul>
<li>类定义处：提供初步的请求映射信息。相对于WEB应用的根目录</li>
<li>方法处：提供进一步的细分映射信息。相对于类定义处的URL，若类定义处未标注@RequestMapping，则方法处标记的URL相对于WEB应用的根目录。<br>举个列子：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Controller</span></span><br><span class="line"><span class="annotation">@RequestMapping</span>(value=<span class="string">"/test"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span></span>&#123;</span><br><span class="line">    <span class="annotation">@RequestMapping</span>(value=<span class="string">"/view"</span>,method = RequestMethod.GET)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">index</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"进来了"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"index"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>上面这样，只要地址访问<a href="http://localhost:8080/SpringMVCMybatis/test/view" target="_blank" rel="external">http://localhost:8080/SpringMVCMybatis/test/view</a> 就能进入这个index方法了，其中使用method属性来指定请求是get还是post。  </p>
<h4 id="（一）使用带占位符URI-PathVariable"><a href="#（一）使用带占位符URI-PathVariable" class="headerlink" title="（一）使用带占位符URI@PathVariable"></a>（一）使用带占位符URI@PathVariable</h4><p>带占位符的URL是Spring3.0新增的功能，该功能在SpringMVC向REST目标挺进发展过程中具有里程碑的意义</p>
<p>通过@PathVariable可以将URL中占位符参数绑定到控制器处理方法的入参中：URL中的{xxx}占位符可以通过@PathVariable(“xxx”)绑定到操作方法入参中。<br>例子：  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * <span class="doctag">@RequestMapping</span> 可以来映射URL中的占位符到目标方法的参数中</span><br><span class="line"> * <span class="doctag">@param</span> id</span><br><span class="line"> * <span class="doctag">@return</span></span><br><span class="line"> */</span></span><br><span class="line"><span class="annotation">@RequestMapping</span>(<span class="string">"/testPathVariable/&#123;id&#125;"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testPathVariable</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span> String id)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"testPathVariable id="</span>+id);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"index"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="（二）使用-RequestParam绑定HttpServletRequest请求参数到控制器方法参数"><a href="#（二）使用-RequestParam绑定HttpServletRequest请求参数到控制器方法参数" class="headerlink" title="（二）使用@RequestParam绑定HttpServletRequest请求参数到控制器方法参数"></a>（二）使用@RequestParam绑定HttpServletRequest请求参数到控制器方法参数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@RequestMapping</span> ( <span class="string">"requestParam"</span> )</span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">testRequestParam</span><span class="params">( @RequestParam(required=<span class="keyword">false</span>)</span> String name, @<span class="title">RequestParam</span> <span class="params">( <span class="string">"age"</span> )</span> <span class="keyword">int</span> age) </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="string">"requestParam"</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面代码中利用@RequestParam从HttpServletRequest 中绑定了参数name 到控制器方法参数name ，绑定了参数age 到控制器方法参数age 。值得注意的是和@PathVariable 一样，当你没有明确指定从request 中取哪个参数时，Spring 在代码是debug 编译的情况下会默认取更方法参数同名的参数，如果不是debug 编译的就会报错。此外，当需要从request 中绑定的参数和方法的参数名不相同的时候，也需要在@RequestParam中明确指出是要绑定哪个参数。在上面的代码中如果我访问/requestParam.do?name=hello&amp;age=1 则Spring 将会把request请求参数name 的值hello 赋给对应的处理方法参数name ，把参数age 的值1 赋给对应的处理方法参数age 。</p>
<p>在@RequestParam 中除了指定绑定哪个参数的属性value 之外，还有一个属性required ，它表示所指定的参数是否必须在request 属性中存在，默认是true ，表示必须存在，当不存在时就会报错。在上面代码中我们指定了参数name 的required 的属性为false ，而没有指定age 的required 属性，这时候如果我们访问/requestParam.do而没有传递参数的时候，系统就会抛出异常，因为age 参数是必须存在的，而我们没有指定。而如果我们访问/requestParam.do?age=1 的时候就可以正常访问，因为我们传递了必须的参数age ，而参数name 是非必须的，不传递也可以。  </p>
<h4 id="（三）使用-CookieValue绑定cookie的值到Controller方法参数"><a href="#（三）使用-CookieValue绑定cookie的值到Controller方法参数" class="headerlink" title="（三）使用@CookieValue绑定cookie的值到Controller方法参数"></a>（三）使用@CookieValue绑定cookie的值到Controller方法参数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@RequestMapping</span> ( <span class="string">"cookieValue"</span> )</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testCookieValue</span><span class="params">( @CookieValue ( <span class="string">"hello"</span> )</span> String cookieValue, @CookieValue String hello) </span>&#123;</span><br><span class="line">       System. out .println(cookieValue + <span class="string">"-----------"</span> + hello);</span><br><span class="line">       <span class="keyword">return</span> <span class="string">"cookieValue"</span> ;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>在上面的代码中我们使用@<strong>CookieValue</strong> 绑定了cookie 的值到方法参数上。上面一共绑定了两个参数，一个是明确指定要绑定的是名称为hello 的cookie 的值，一个是没有指定。使用没有指定的形式的规则和@<strong>PathVariable</strong>、@<strong>RequestParam</strong> 的规则是一样的，即在debug 编译模式下将自动获取跟方法参数名同名的cookie 值。  </p>
<h4 id="（四）使用-RequestHeader注解绑定-HttpServletRequest头信息到Controller方法参数"><a href="#（四）使用-RequestHeader注解绑定-HttpServletRequest头信息到Controller方法参数" class="headerlink" title="（四）使用@RequestHeader注解绑定 HttpServletRequest头信息到Controller方法参数"></a>（四）使用@RequestHeader注解绑定 HttpServletRequest头信息到Controller方法参数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@RequestMapping</span> ( <span class="string">"testRequestHeader"</span> )</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testRequestHeader</span><span class="params">( @RequestHeader ( <span class="string">"Host"</span> )</span> String hostAddr, @RequestHeader String Host, @RequestHeader String host ) </span>&#123;</span><br><span class="line">    System. out .println(hostAddr + <span class="string">"-----"</span> + Host + <span class="string">"-----"</span> + host );</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"requestHeader"</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的代码中我们使用了 @<strong>RequestHeader</strong> 绑定了 HttpServletRequest 请求头 host 到Controller 的方法参数。上面方法的三个参数都将会赋予同一个值，由此我们可以知道在绑定请求头参数到方法参数的时候规则和 @<strong>PathVariable</strong> 、 @<strong>RequestParam</strong> 以及 @<strong>CookieValue</strong> 是一样的，即没有指定绑定哪个参数到方法参数的时候，在 debug 编译模式下将使用方法参数名作为需要绑定的参数。但是有一点 @<strong>RequestHeader</strong> 跟另外三种绑定方式是不一样的，那就是在使用 @<strong>RequestHeader </strong>的时候是大小写不敏感的，即 @RequestHeader(“Host”) 和 @RequestHeader(“host”) 绑定的都是 Host 头信息。记住在 @<strong>PathVariable</strong> 、 @<strong>RequestParam</strong> 和 @<strong>CookieValue</strong> 中都是大小写敏感的。  </p>
<h4 id="（五）-RequestMapping的一些高级应用"><a href="#（五）-RequestMapping的一些高级应用" class="headerlink" title="（五）@RequestMapping的一些高级应用"></a>（五）@RequestMapping的一些高级应用</h4><p>在RequestMapping 中除了指定请求路径value 属性外，还有其他的属性可以指定，如params 、method 和headers 。这样属性都可以用于缩小请求的映射范围。<br><strong>1.params属性</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@RequestMapping</span> (value= <span class="string">"testParams"</span> , params=&#123; <span class="string">"param1=value1"</span> , <span class="string">"param2"</span> , <span class="string">"!param3"</span> &#125;)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testParams</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       System. out .println( <span class="string">"test Params..........."</span> );</span><br><span class="line">       <span class="keyword">return</span> <span class="string">"testParams"</span> ;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>在上面的代码中我们用@RequestMapping 的params 属性指定了三个参数，这些参数都是针对请求参数而言的，它们分别表示参数param1 的值必须等于value1 ，参数param2 必须存在，值无所谓，参数param3 必须不存在，只有当请求/testParams.do 并且满足指定的三个参数条件的时候才能访问到该方法。所以当请求/testParams.do?param1=value1&amp;param2=value2 的时候能够正确访问到该testParams 方法，当请求/testParams.do?param1=value1&amp;param2=value2&amp;param3=value3 的时候就不能够正常的访问到该方法，因为在@RequestMapping 的params 参数里面指定了参数param3 是不能存在的。</p>
<p><strong>2.method属性</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@RequestMapping</span> (value= <span class="string">"testMethod"</span> , method=&#123;RequestMethod. GET , RequestMethod. DELETE &#125;)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="string">"method"</span> ;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>在上面的代码中就使用method 参数限制了以GET 或DELETE 方法请求/testMethod.do 的时候才能访问到该Controller 的testMethod 方法。</p>
<p><strong>3.headers属性</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@RequestMapping</span> (value= <span class="string">"testHeaders"</span> , headers=&#123; <span class="string">"host=localhost"</span> , <span class="string">"Accept"</span> &#125;)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testHeaders</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="string">"headers"</span> ;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>headers 属性的用法和功能与params 属性相似。在上面的代码中当请求/testHeaders.do 的时候只有当请求头包含Accept 信息，且请求的host 为localhost 的时候才能正确的访问到testHeaders 方法。  </p>
<h4 id="（六）以-RequestMapping标记的处理器方法支持的方法参数和返回类型"><a href="#（六）以-RequestMapping标记的处理器方法支持的方法参数和返回类型" class="headerlink" title="（六）以@RequestMapping标记的处理器方法支持的方法参数和返回类型"></a>（六）以@RequestMapping标记的处理器方法支持的方法参数和返回类型</h4><h5 id="1-支持的方法参数类型"><a href="#1-支持的方法参数类型" class="headerlink" title="1. 支持的方法参数类型"></a>1. 支持的方法参数类型</h5><ol>
<li><p>HttpServlet 对象，主要包括HttpServletRequest 、HttpServletResponse 和HttpSession 对象。 这些参数Spring 在调用处理器方法的时候会自动给它们赋值，所以当在处理器方法中需要使用到这些对象的时候，可以直接在方法上给定一个方法参数的申明，然后在方法体里面直接用就可以了。但是有一点需要注意的是在使用HttpSession 对象的时候，如果此时HttpSession 对象还没有建立起来的话就会有问题。</p>
</li>
<li><p>Spring 自己的WebRequest 对象。 使用该对象可以访问到存放在HttpServletRequest 和HttpSession 中的属性值。</p>
</li>
<li><p>InputStream 、OutputStream 、Reader 和Writer 。 InputStream 和Reader 是针对HttpServletRequest 而言的，可以从里面取数据；OutputStream 和Writer 是针对HttpServletResponse 而言的，可以往里面写数据。</p>
</li>
<li><p>使用@PathVariable 、@RequestParam 、@CookieValue 和@RequestHeader 标记的参数。</p>
</li>
<li><p>使用@ModelAttribute 标记的参数。</p>
</li>
<li><p>java.util.Map 、Spring 封装的Model 和ModelMap 。 这些都可以用来封装模型数据，用来给视图做展示。</p>
</li>
<li><p>实体类。 可以用来接收上传的参数。</p>
</li>
<li><p>Spring 封装的MultipartFile 。 用来接收上传文件的。</p>
</li>
<li><p>Spring 封装的Errors 和BindingResult 对象。 这两个对象参数必须紧接在需要验证的实体对象参数之后，它里面包含了实体对象的验证结果。   </p>
</li>
</ol>
<h5 id="2-支持的返回类型"><a href="#2-支持的返回类型" class="headerlink" title="2. 支持的返回类型"></a>2. 支持的返回类型</h5><ol>
<li><p>一个包含模型和视图的ModelAndView 对象。</p>
</li>
<li><p>一个模型对象，这主要包括Spring 封装好的Model 和ModelMap ，以及java.util.Map ，当没有视图返回的时候视图名称将由RequestToViewNameTranslator 来决定。</p>
</li>
<li><p>一个View 对象。这个时候如果在渲染视图的过程中模型的话就可以给处理器方法定义一个模型参数，然后在方法体里面往模型中添加值。</p>
</li>
<li><p>一个String 字符串。这往往代表的是一个视图名称。这个时候如果需要在渲染视图的过程中需要模型的话就可以给处理器方法一个模型参数，然后在方法体里面往模型中添加值就可以了。</p>
</li>
<li><p>返回值是void 。这种情况一般是我们直接把返回结果写到HttpServletResponse 中了，如果没有写的话，那么Spring 将会利用RequestToViewNameTranslator 来返回一个对应的视图名称。如果视图中需要模型的话，处理方法与返回字符串的情况相同。</p>
</li>
<li><p>如果处理器方法被注解@ResponseBody 标记的话，那么处理器方法的任何返回类型都会通过HttpMessageConverters 转换之后写到HttpServletResponse 中，而不会像上面的那些情况一样当做视图或者模型来处理。</p>
</li>
<li><p>除以上几种情况之外的其他任何返回类型都会被当做模型中的一个属性来处理，而返回的视图还是由RequestToViewNameTranslator 来决定，添加到模型中的属性名称可以在该方法上用@ModelAttribute(“attributeName”) 来定义，否则将使用返回类型的类名称的首字母小写形式来表示。使用@ModelAttribute 标记的方法会在@RequestMapping 标记的方法执行之前执行。</p>
</li>
</ol>
<h4 id="（七）使用-ModelAttribute-和-SessionAttributes-传递和保存数据"><a href="#（七）使用-ModelAttribute-和-SessionAttributes-传递和保存数据" class="headerlink" title="（七）使用 @ModelAttribute 和 @SessionAttributes 传递和保存数据"></a>（七）使用 @ModelAttribute 和 @SessionAttributes 传递和保存数据</h4><p>SpringMVC 支持使用 @<strong>ModelAttribute</strong> 和 @<strong>SessionAttributes</strong> 在不同的模型和控制器之间共享数据。 <strong>@ModelAttribute </strong>主要有两种使用方式，一种是标注在方法上，一种是标注在 Controller 方法参数上。</p>
<p>当 @<strong>ModelAttribute</strong> 标记在方法上的时候，该方法将在处理器方法执行之前执行，然后把返回的对象存放在 session 或模型属性中，属性名称可以使用 @<strong>ModelAttribute</strong>(“attributeName”) 在标记方法的时候指定，若未指定，则使用返回类型的类名称（首字母小写）作为属性名称。关于 @ModelAttribute 标记在方法上时对应的属性是存放在 session 中还是存放在模型中，我们来做一个实验，看下面一段代码。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Controller</span></span><br><span class="line"><span class="annotation">@RequestMapping</span> ( <span class="string">"/myTest"</span> )</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@ModelAttribute</span> ( <span class="string">"hello"</span> )</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getModel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       System. out .println( <span class="string">"-------------Hello---------"</span> );</span><br><span class="line">       <span class="keyword">return</span> <span class="string">"world"</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@ModelAttribute</span> ( <span class="string">"intValue"</span> )</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getInteger</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       System. out .println( <span class="string">"-------------intValue---------------"</span> );</span><br><span class="line">       <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@RequestMapping</span> ( <span class="string">"sayHello"</span> )</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">( @ModelAttribute ( <span class="string">"hello"</span> )</span> String hello, @<span class="title">ModelAttribute</span> <span class="params">( <span class="string">"intValue"</span> )</span> <span class="keyword">int</span> num, @<span class="title">ModelAttribute</span> <span class="params">( <span class="string">"user2"</span> )</span> User user, Writer writer, HttpSession session) <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">       writer.write( <span class="string">"Hello "</span> + hello + <span class="string">" , Hello "</span> + user.getUsername() + num);</span><br><span class="line">       writer.write( <span class="string">"\r"</span> );</span><br><span class="line">       Enumeration enume = session.getAttributeNames();</span><br><span class="line">       <span class="keyword">while</span> (enume.hasMoreElements())</span><br><span class="line">           writer.write(enume.nextElement() + <span class="string">"\r"</span> );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@ModelAttribute</span> ( <span class="string">"user2"</span> )</span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       System. out .println( <span class="string">"---------getUser-------------"</span> );</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> User(<span class="number">3</span>, <span class="string">"user2"</span> );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当我们请求 /myTest/sayHello.do 的时候使用 @ModelAttribute 标记的方法会先执行，然后把它们返回的对象存放到模型中。最终访问到 sayHello 方法的时候，使用 @ModelAttribute 标记的方法参数都能被正确的注入值。执行结果如下所示：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello world,Hello user210</span><br></pre></td></tr></table></figure></p>
<p>由执行结果我们可以看出来，此时 session 中没有包含任何属性，也就是说上面的那些对象都是存放在模型属性中，而不是存放在 session 属性中。那要如何才能存放在 session 属性中呢？这个时候我们先引入一个新的概念 @SessionAttributes ，它的用法会在讲完 @ModelAttribute 之后介绍，这里我们就先拿来用一下。我们在 MyController 类上加上 @SessionAttributes 属性标记哪些是需要存放到 session 中的。看下面的代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Controller</span></span><br><span class="line"><span class="annotation">@RequestMapping</span> ( <span class="string">"/myTest"</span> )</span><br><span class="line"><span class="annotation">@SessionAttributes</span> (value=&#123; <span class="string">"intValue"</span> , <span class="string">"stringValue"</span> &#125;, types=&#123;User. <span class="class"><span class="keyword">class</span> &#125;)</span><br><span class="line"><span class="title">public</span> <span class="title">class</span> <span class="title">MyController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@ModelAttribute</span> ( <span class="string">"hello"</span> )</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getModel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       System. out .println( <span class="string">"-------------Hello---------"</span> );</span><br><span class="line">       <span class="keyword">return</span> <span class="string">"world"</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@ModelAttribute</span> ( <span class="string">"intValue"</span> )</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getInteger</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       System. out .println( <span class="string">"-------------intValue---------------"</span> );</span><br><span class="line">       <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="annotation">@RequestMapping</span> ( <span class="string">"sayHello"</span> )</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(Map&lt;String, Object&gt; map, @ModelAttribute ( <span class="string">"hello"</span> )</span> String hello, @<span class="title">ModelAttribute</span> <span class="params">( <span class="string">"intValue"</span> )</span> <span class="keyword">int</span> num, @<span class="title">ModelAttribute</span> <span class="params">( <span class="string">"user2"</span> )</span> User user, Writer writer, HttpServletRequest request) <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">       map.put( <span class="string">"stringValue"</span> , <span class="string">"String"</span> );</span><br><span class="line">       writer.write( <span class="string">"Hello "</span> + hello + <span class="string">" , Hello "</span> + user.getUsername() + num);</span><br><span class="line">       writer.write( <span class="string">"\r"</span> );</span><br><span class="line">       HttpSession session = request.getSession();</span><br><span class="line">       Enumeration enume = session.getAttributeNames();</span><br><span class="line">       <span class="keyword">while</span> (enume.hasMoreElements())</span><br><span class="line">           writer.write(enume.nextElement() + <span class="string">"\r"</span> );</span><br><span class="line">       System. out .println(session);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@ModelAttribute</span> ( <span class="string">"user2"</span> )</span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       System. out .println( <span class="string">"---------getUser-------------"</span> );</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> User(<span class="number">3</span>, <span class="string">"user2"</span> );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在上面代码中我们指定了属性为 intValue 或 stringValue 或者类型为 User 的都会放到 Session中，利用上面的代码当我们访问 /myTest/sayHello.do 的时候，结果如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello world,Hello user210</span><br></pre></td></tr></table></figure></p>
<p>仍然没有打印出任何 session 属性，这是怎么回事呢？怎么定义了把模型中属性名为 intValue 的对象和类型为 User 的对象存到 session 中，而实际上没有加进去呢？难道我们错啦？我们当然没有错，只是在第一次访问 /myTest/sayHello.do 的时候 @SessionAttributes 定义了需要存放到 session 中的属性，而且这个模型中也有对应的属性，但是这个时候还没有加到 session 中，所以 session 中不会有任何属性，等处理器方法执行完成后 Spring 才会把模型中对应的属性添加到 session 中。所以当请求第二次的时候就会出现如下结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Hello world,Hello user210</span><br><span class="line">user2</span><br><span class="line">intValue</span><br><span class="line">stringValue</span><br></pre></td></tr></table></figure></p>
<p>当 @ModelAttribute 标记在处理器方法参数上的时候，表示该参数的值将从模型或者 Session 中取对应名称的属性值，该名称可以通过 @ModelAttribute(“attributeName”) 来指定，若未指定，则使用参数类型的类名称（首字母小写）作为属性名称。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>到此，SpringMVC的原理以及常用注解就介绍的差不多了，平时开发这些就够用了，如果你还想深入学习SpringMVC知识点，可以关注我个人公众号，里面资源贴有全套的视频教程。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://www.cnblogs.com/xdp-gacl/p/3495887.html" target="_blank" rel="external">Spring常用注解</a><br><a href="http://www.cnphp6.com/archives/59355" target="_blank" rel="external">@AUTOWIRED与@RESOURCE的区别</a><br><a href="http://www.cnblogs.com/xiepeixing/p/4243288.html" target="_blank" rel="external">SpringMVC Controller介绍及常用注解</a></p>
<hr>
<p>一直觉得自己写的不是技术，而是情怀，一篇篇文章是自己这一路走来的痕迹。靠专业技能的成功是最具可复制性的，希望我的这条路能让你少走弯路，希望我能帮你抹去知识的蒙尘，希望我能帮你理清知识的脉络，希望未来技术之巅上有你也有我。</p>
<hr>
<p> 博主弄了个java学习资源的公众号，学习资源超级多，视频，电子书，最新开发工具一个都不能少，已全部分享到百度云盘，求资源共享，打造一个学习方便，工作方便的java公众号，开源开源，有需求的可以关注~撒花<br> <img src="http://7xqch5.com1.z0.glb.clouddn.com/javaLearn.PNG" alt=""></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/springMVC/">springMVC</a>
    </div>


      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-javareflect" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/04/28/javareflect/" class="article-date">
      <time datetime="2016-04-28T12:04:00.000Z" itemprop="datePublished">2016-04-28</time>
</a>

 
    <a href="/2016/04/28/javareflect/#comments" title="查看评论">
        <i class="fa fa-comments-o" aria-hidden="true"></i>
        <span class="count-comment"></span>
        
            <span class="ds-thread-count"  data-thread-key="2016/04/28/javareflect/" ></span>
        
        
    </a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/28/javareflect/">Java基础与提高干货系列——Java反射机制</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>今天介绍下Java的反射机制，以前我们获取一个类的实例都是使用new一个实例出来。那样太low了，今天跟我一起来学习学习一种更加高大上的方式来实现。</p>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="Java反射机制定义"><a href="#Java反射机制定义" class="headerlink" title="Java反射机制定义"></a>Java反射机制定义</h2><p>Java反射机制是指在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。<br>用一句话总结就是反射可以实现在运行时可以知道任意一个类的属性和方法。</p>
<h2 id="反射机制的优点与缺点"><a href="#反射机制的优点与缺点" class="headerlink" title="反射机制的优点与缺点"></a>反射机制的优点与缺点</h2><p>为什么要用反射机制？直接创建对象不就可以了吗，这就涉及到了动态与静态的概念</p>
<ul>
<li>静态编译：在编译时确定类型，绑定对象,即通过。</li>
<li><p>动态编译：运行时确定类型，绑定对象。动态编译最大限度发挥了java的灵活性，体现了多态的应用，有以降低类之间的藕合性。</p>
</li>
<li><p>优点<br>可以实现动态创建对象和编译，体现出很大的灵活性，特别是在J2EE的开发中它的灵活性就表现的十分明显。比如，一个大型的软件，不可能一次就把把它设计的很完美，当这个程序编译后，发布了，当发现需要更新某些功能时，我们不可能要用户把以前的卸载，再重新安装新的版本，假如这样的话，这个软件肯定是没有多少人用的。采用静态的话，需要把整个程序重新编译一次才可以实现功能的更新，而采用反射机制的话，它就可以不用卸载，只需要在运行时才动态的创建和编译，就可以实现该功能。</p>
</li>
<li>缺点<br>对性能有影响。使用反射基本上是一种解释操作，我们可以告诉JVM，我们希望做什么并且它满足我们的要求。这类操作总是慢于只直接执行相同的操作。</li>
</ul>
<h2 id="理解Class类和类类型"><a href="#理解Class类和类类型" class="headerlink" title="理解Class类和类类型"></a>理解Class类和类类型</h2><p>想要了解反射首先理解一下Class类，它是反射实现的基础。<br>类是java.lang.Class类的实例对象，而Class是所有类的类（There is a class named Class）<br>对于普通的对象，我们一般都会这样创建和表示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Code code1 = <span class="keyword">new</span> Code();</span><br></pre></td></tr></table></figure></p>
<p>上面说了，所有的类都是Class的对象，那么如何表示呢，可不可以通过如下方式呢：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class c = <span class="keyword">new</span> Class();</span><br></pre></td></tr></table></figure></p>
<p>但是我们查看Class的源码时，是这样写的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span>  <span class="title">Class</span><span class="params">(ClassLoader loader)</span> </span>&#123; </span><br><span class="line">    classLoader = loader; </span><br><span class="line">&#125;</span><br><span class="line">``` </span><br><span class="line">可以看到构造器是私有的，只有JVM可以创建Class的对象，因此不可以像普通类一样<span class="keyword">new</span>一个Class对象，虽然我们不能<span class="keyword">new</span>一个Class对象，但是却可以通过已有的类得到一个Class对象，共有三种方式，如下：</span><br><span class="line">``` java</span><br><span class="line">Class c1 = Code.class;</span><br><span class="line">这说明任何一个类都有一个隐含的静态成员变量<span class="class"><span class="keyword">class</span>，这种方式是通过获取类的静态成员变量<span class="title">class</span>得到的</span><br><span class="line"><span class="title">Class</span> <span class="title">c2</span> </span>= code1.getClass();</span><br><span class="line">code1是Code的一个对象，这种方式是通过一个类的对象的getClass()方法获得的</span><br><span class="line">Class c3 = Class.forName(<span class="string">"com.trigl.reflect.Code"</span>);</span><br><span class="line">这种方法是Class类调用forName方法，通过一个类的全量限定名获得</span><br></pre></td></tr></table></figure></p>
<p>这里，c1、c2、c3都是Class的对象，他们是完全一样的，而且有个学名，叫做Code的类类型（class type）。<br>这里就让人奇怪了，前面不是说Code是Class的对象吗，而c1、c2、c3也是Class的对象，那么Code和c1、c2、c3不就一样了吗？为什么还叫Code什么类类型？这里不要纠结于它们是否相同，只要理解类类型是干什么的就好了，顾名思义，类类型就是类的类型，也就是描述一个类是什么，都有哪些东西，所以我们可以通过类类型知道一个类的属性和方法，并且可以调用一个类的属性和方法，这就是反射的基础。</p>
<p>举个简单例子代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">//第一种：Class c1 = Code.class;</span></span><br><span class="line">        Class class1=ReflectDemo.class;</span><br><span class="line">        System.out.println(class1.getName());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第二种：Class c2 = code1.getClass();</span></span><br><span class="line">        ReflectDemo demo2= <span class="keyword">new</span> ReflectDemo();</span><br><span class="line">        Class c2 = demo2.getClass();</span><br><span class="line">        System.out.println(c2.getName());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第三种：Class c3 = Class.forName("com.trigl.reflect.Code");</span></span><br><span class="line">        Class class3 = Class.forName(<span class="string">"com.tengj.reflect.ReflectDemo"</span>);</span><br><span class="line">        System.out.println(class3.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>执行结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">com.tengj.reflect.ReflectDemo</span><br><span class="line">com.tengj.reflect.ReflectDemo</span><br><span class="line">com.tengj.reflect.ReflectDemo</span><br></pre></td></tr></table></figure></p>
<h2 id="Java反射相关操作"><a href="#Java反射相关操作" class="headerlink" title="Java反射相关操作"></a>Java反射相关操作</h2><p>前面我们知道了怎么获取Class，那么我们可以通过这个Class干什么呢？<br>总结如下：</p>
<ul>
<li>获取成员方法Method</li>
<li>获取成员变量Field</li>
<li>获取构造函数Constructor</li>
</ul>
<p>下面来具体介绍</p>
<h3 id="获取成员方法信息"><a href="#获取成员方法信息" class="headerlink" title="获取成员方法信息"></a>获取成员方法信息</h3><p>单独获取某一个方法是通过Class类的以下方法获得的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Method <span class="title">getDeclaredMethod</span><span class="params">(String name, Class&lt;?&gt;... parameterTypes)</span> <span class="comment">// 得到该类所有的方法，不包括父类的</span></span><br><span class="line"><span class="keyword">public</span> Method <span class="title">getMethod</span><span class="params">(String name, Class&lt;?&gt;... parameterTypes)</span> <span class="comment">// 得到该类所有的public方法，包括父类的</span></span></span><br></pre></td></tr></table></figure></p>
<p>两个参数分别是方法名和方法参数类的类类型列表。<br>例如类A有如下一个方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">(String name,<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我叫"</span>+name+<span class="string">",今年"</span>+age+<span class="string">"岁"</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>现在知道A有一个对象a，那么就可以通过：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Class c = Class.forName(<span class="string">"com.tengj.reflect.Person"</span>);  <span class="comment">//先生成class</span></span><br><span class="line">Object o = c.newInstance();                           <span class="comment">//newInstance可以初始化一个实例</span></span><br><span class="line">Method method = c.getMethod(<span class="string">"fun"</span>, String.class, <span class="keyword">int</span>.class);<span class="comment">//获取方法</span></span><br><span class="line">method.invoke(o, <span class="string">"tengj"</span>, <span class="number">10</span>);                              <span class="comment">//通过invoke调用该方法，参数第一个为实例对象，后面为具体参数值</span></span><br></pre></td></tr></table></figure></p>
<p>完整代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String msg=<span class="string">"hello wrold"</span>;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Person</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">  System.out.println(name);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"fun"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">(String name,<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我叫"</span>+name+<span class="string">",今年"</span>+age+<span class="string">"岁"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class c = Class.forName(<span class="string">"com.tengj.reflect.Person"</span>);</span><br><span class="line">            Object o = c.newInstance();</span><br><span class="line">            Method method = c.getMethod(<span class="string">"fun"</span>, String.class, <span class="keyword">int</span>.class);</span><br><span class="line">            method.invoke(o, <span class="string">"tengj"</span>, <span class="number">10</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>执行结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">我叫tengj,今年<span class="number">10</span>岁</span><br></pre></td></tr></table></figure></p>
<p>怎样，是不是感觉很厉害，我们只要知道这个类的路径全称就能玩弄它于鼓掌之间。</p>
<p>有时候我们想获取类中所有成员方法的信息，要怎么办。可以通过以下几步来实现：<br>1.获取所有方法的数组：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class c = Class.forName(&#34;com.tengj.reflect.Person&#34;);&#10;Method[] methods = c.getDeclaredMethods(); // &#24471;&#21040;&#35813;&#31867;&#25152;&#26377;&#30340;&#26041;&#27861;&#65292;&#19981;&#21253;&#25324;&#29238;&#31867;&#30340;&#10;&#25110;&#32773;&#65306;&#10;Method[] methods = c.getMethods();// &#24471;&#21040;&#35813;&#31867;&#25152;&#26377;&#30340;public&#26041;&#27861;&#65292;&#21253;&#25324;&#29238;&#31867;&#30340;</span><br></pre></td></tr></table></figure></p>
<p>2.然后循环这个数组就得到每个方法了：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (Method method : methods)</span><br></pre></td></tr></table></figure></p>
<p>完整代码如下：<br>person类跟上面一样，这里以及后面就不贴出来了，只贴关键代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class c = Class.forName(<span class="string">"com.tengj.reflect.Person"</span>);</span><br><span class="line">            Method[] methods = c.getDeclaredMethods();</span><br><span class="line">            <span class="keyword">for</span>(Method m:methods)&#123;</span><br><span class="line">                String  methodName= m.getName();</span><br><span class="line">                System.out.println(methodName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>执行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getName&#10;setName&#10;setAge&#10;fun&#10;fun&#10;getAge</span><br></pre></td></tr></table></figure></p>
<p>这里如果把c.getDeclaredMethods();改成c.getMethods();执行结果如下，多了很多方法，以为把Object里面的方法也打印出来了，因为Object是所有类的父类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">getName</span><br><span class="line">setName</span><br><span class="line">getAge</span><br><span class="line">setAge</span><br><span class="line">fun</span><br><span class="line">fun</span><br><span class="line">wait</span><br><span class="line">wait</span><br><span class="line">wait</span><br><span class="line">equals</span><br><span class="line">toString</span><br><span class="line">hashCode</span><br><span class="line">getClass</span><br><span class="line">notify</span><br><span class="line">notifyAll</span><br></pre></td></tr></table></figure></p>
<h3 id="获取成员变量信息"><a href="#获取成员变量信息" class="headerlink" title="获取成员变量信息"></a>获取成员变量信息</h3><p>想一想成员变量中都包括什么：成员变量类型+成员变量名<br>类的成员变量也是一个对象，它是<code>java.lang.reflect.Field</code>的一个对象，所以我们通过<code>java.lang.reflect.Field</code>里面封装的方法来获取这些信息。</p>
<p>单独获取某个成员变量，通过Class类的以下方法实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Field <span class="title">getDeclaredField</span><span class="params">(String name)</span> <span class="comment">// 获得该类自身声明的所有变量，不包括其父类的变量</span></span><br><span class="line"><span class="keyword">public</span> Field <span class="title">getField</span><span class="params">(String name)</span> <span class="comment">// 获得该类自所有的public成员变量，包括其父类变量</span></span></span><br></pre></td></tr></table></figure></p>
<p>参数是成员变量的名字。<br>例如一个类A有如下成员变量：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> n;</span><br></pre></td></tr></table></figure></p>
<p>如果A有一个对象a，那么就可以这样得到其成员变量：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class c = a.getClass();</span><br><span class="line">Field field = c.getDeclaredField(<span class="string">"n"</span>);</span><br></pre></td></tr></table></figure></p>
<p>完整代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class c = Class.forName(<span class="string">"com.tengj.reflect.Person"</span>);</span><br><span class="line">            <span class="comment">//获取成员变量</span></span><br><span class="line">            Field field = c.getDeclaredField(<span class="string">"msg"</span>); <span class="comment">//因为msg变量是private的，所以不能用getField方法</span></span><br><span class="line">            Object o = c.newInstance();</span><br><span class="line">            field.setAccessible(<span class="keyword">true</span>);<span class="comment">//设置是否允许访问，因为该变量是private的，所以要手动设置允许访问，如果msg是public的就不需要这行了。</span></span><br><span class="line">            Object msg = field.get(o);</span><br><span class="line">            System.out.println(msg);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>执行结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello wrold</span><br></pre></td></tr></table></figure></p>
<p>同样，如果想要获取所有成员变量的信息，可以通过以下几步<br>1.获取所有成员变量的数组：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Field[] fields = c.getDeclaredFields();</span><br></pre></td></tr></table></figure></p>
<p>2.遍历变量数组，获得某个成员变量field<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for (Field field : fields)</span><br></pre></td></tr></table></figure></p>
<p>完整代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class c = Class.forName(<span class="string">"com.tengj.reflect.Person"</span>);</span><br><span class="line">            Field[] fields = c.getDeclaredFields();</span><br><span class="line">            <span class="keyword">for</span>(Field field :fields)&#123;</span><br><span class="line">                System.out.println(field.getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>执行结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">name</span><br><span class="line">age</span><br><span class="line">msg</span><br></pre></td></tr></table></figure></p>
<h3 id="获取构造函数"><a href="#获取构造函数" class="headerlink" title="获取构造函数"></a>获取构造函数</h3><p>最后再想一想构造函数中都包括什么：构造函数参数<br>同上，类的成构造函数也是一个对象，它是<code>java.lang.reflect.Constructor</code>的一个对象，所以我们通过<code>java.lang.reflect.Constructor</code>里面封装的方法来获取这些信息。</p>
<p>单独获取某个构造函数,通过Class类的以下方法实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Constructor&lt;T&gt; <span class="title">getDeclaredConstructor</span><span class="params">(Class&lt;?&gt;... parameterTypes)</span> <span class="comment">//  获得该类所有的构造器，不包括其父类的构造器</span></span><br><span class="line"><span class="keyword">public</span> Constructor&lt;T&gt; <span class="title">getConstructor</span><span class="params">(Class&lt;?&gt;... parameterTypes)</span> <span class="comment">// 获得该类所以public构造器，包括父类</span></span></span><br></pre></td></tr></table></figure></p>
<p>这个参数为构造函数参数类的类类型列表。<br>例如类A有如下一个构造函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public A(String a, int b) &#123;&#10;    // code body&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>那么就可以通过：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Constructor constructor = a.getDeclaredConstructor(String.class, int.class);</span><br></pre></td></tr></table></figure></p>
<p>来获取这个构造函数。</p>
<p>完整代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class c = Class.forName(<span class="string">"com.tengj.reflect.Person"</span>);</span><br><span class="line">            <span class="comment">//获取构造函数</span></span><br><span class="line">            Constructor constructor = c.getDeclaredConstructor(String.class);</span><br><span class="line">            constructor.setAccessible(<span class="keyword">true</span>);<span class="comment">//设置是否允许访问，因为该构造器是private的，所以要手动设置允许访问，如果构造器是public的就不需要这行了。</span></span><br><span class="line">            constructor.newInstance(<span class="string">"tengj"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>执行结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tengj</span><br></pre></td></tr></table></figure></p>
<p>注意：Class的newInstance方法，只能创建只包含无参数的构造函数的类，如果某类只有带参数的构造函数，那么就要使用另外一种方式：fromClass.getDeclaredConstructor(String.class).newInstance(“tengj”);</p>
<p>获取所有的构造函数，可以通过以下步骤实现：<br>1.获取该类的所有构造函数，放在一个数组中：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Constructor[] constructors = c.getDeclaredConstructors();</span><br></pre></td></tr></table></figure></p>
<p>2.遍历构造函数数组，获得某个构造函数constructor:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (Constructor constructor : constructors)</span><br></pre></td></tr></table></figure></p>
<p>完整代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">            Constructor[] constructors = c.getDeclaredConstructors();</span><br><span class="line">            <span class="keyword">for</span>(Constructor constructor:constructors)&#123;</span><br><span class="line">                System.out.println(constructor);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>执行结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> com.tengj.reflect.Person()</span><br><span class="line"><span class="keyword">public</span> com.tengj.reflect.Person(java.lang.String)</span><br></pre></td></tr></table></figure></p>
<h2 id="通过反射了解集合泛型的本质"><a href="#通过反射了解集合泛型的本质" class="headerlink" title="通过反射了解集合泛型的本质"></a>通过反射了解集合泛型的本质</h2><p>首先下结论：</p>
<blockquote>
<p>Java中集合的泛型，是防止错误输入的，只在编译阶段有效，绕过编译到了运行期就无效了。</p>
</blockquote>
<p>下面通过一个实例来验证：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 集合泛型的本质</span><br><span class="line"> * <span class="doctag">@description</span></span><br><span class="line"> * <span class="doctag">@author</span> Trigl</span><br><span class="line"> * <span class="doctag">@date</span> 2016年4月2日上午2:54:11</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericEssence</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List list1 = <span class="keyword">new</span> ArrayList(); <span class="comment">// 没有泛型 </span></span><br><span class="line">        List&lt;String&gt; list2 = <span class="keyword">new</span> ArrayList&lt;String&gt;(); <span class="comment">// 有泛型</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span><br><span class="line">         * 1.首先观察正常添加元素方式，在编译器检查泛型，</span><br><span class="line">         * 这个时候如果list2添加int类型会报错</span><br><span class="line">         */</span></span><br><span class="line">        list2.add(<span class="string">"hello"</span>);</span><br><span class="line"><span class="comment">//      list2.add(20); // 报错！list2有泛型限制，只能添加String，添加int报错</span></span><br><span class="line">        System.out.println(<span class="string">"list2的长度是："</span> + list2.size()); <span class="comment">// 此时list2长度为1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span><br><span class="line">         * 2.然后通过反射添加元素方式，在运行期动态加载类，首先得到list1和list2</span><br><span class="line">         * 的类类型相同，然后再通过方法反射绕过编译器来调用add方法，看能否插入int</span><br><span class="line">         * 型的元素</span><br><span class="line">         */</span></span><br><span class="line">        Class c1 = list1.getClass();</span><br><span class="line">        Class c2 = list2.getClass();</span><br><span class="line">        System.out.println(c1 == c2); <span class="comment">// 结果：true，说明类类型完全相同</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 验证：我们可以通过方法的反射来给list2添加元素，这样可以绕过编译检查</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Method m = c2.getMethod(<span class="string">"add"</span>, Object.class); <span class="comment">// 通过方法反射得到add方法</span></span><br><span class="line">            m.invoke(list2, <span class="number">20</span>); <span class="comment">// 给list2添加一个int型的，上面显示在编译器是会报错的</span></span><br><span class="line">            System.out.println(<span class="string">"list2的长度是："</span> + list2.size()); <span class="comment">// 结果：2，说明list2长度增加了，并没有泛型检查</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span><br><span class="line">         * 综上可以看出，在编译器的时候，泛型会限制集合内元素类型保持一致，但是编译器结束进入</span><br><span class="line">         * 运行期以后，泛型就不再起作用了，即使是不同类型的元素也可以插入集合。</span><br><span class="line">         */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>执行结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">list2的长度是：<span class="number">1</span></span><br><span class="line"><span class="keyword">true</span></span><br><span class="line">list2的长度是：<span class="number">2</span></span><br></pre></td></tr></table></figure></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>到此，Java反射机制入门的差不多了，我是复习SpringMVC里面IOC/DI的时候，是通过Java反射来实现的，希望这篇笔记也对你有用。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://www.cnblogs.com/hxsyl/archive/2013/03/23/2977593.html" target="_blank" rel="external">Java反射机制深入详解</a><br><a href="http://blog.csdn.net/trigl/article/details/51042403" target="_blank" rel="external">Java反射入门</a><br><a href="http://www.cnblogs.com/jqyp/archive/2012/03/29/2423112.html" target="_blank" rel="external">Java反射机制</a><br><a href="http://www.cnblogs.com/rollenholt/archive/2011/09/02/2163758.html" target="_blank" rel="external">java反射详解</a><br><a href="http://www.cnblogs.com/gulvzhe/archive/2012/01/27/2330001.html" target="_blank" rel="external">Java 反射机制浅析</a><br><a href="http://uule.iteye.com/blog/1423512" target="_blank" rel="external">反射机制的理解及其用途</a></p>
<h1 id="整理的思维导图"><a href="#整理的思维导图" class="headerlink" title="整理的思维导图"></a>整理的思维导图</h1><p>个人整理的Java反射机制的思维导图,导出的图片无法查看备注的一些信息，所以需要源文件的童鞋可以关注我个人主页上的公众号，回复<strong>反射机制</strong>即可获取源文件。<br><img src="http://7xqch5.com1.z0.glb.clouddn.com/Javareflect.png" alt=""></p>
<hr>
<p>博主弄了个java学习资源的公众号，学习资源超级多，视频，电子书，最新开发工具一个都不能少，已全部分享到百度云盘，求资源共享，打造一个学习方便，工作方便的java公众号，开源开源，有需求的可以关注~撒花<br>  <img src="http://7xqch5.com1.z0.glb.clouddn.com/javaLearn.PNG" alt=""></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Java基础与提高干货系列/">Java基础与提高干货系列</a>
    </div>


      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-thread1" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/04/24/thread1/" class="article-date">
      <time datetime="2016-04-24T02:12:04.000Z" itemprop="datePublished">2016-04-24</time>
</a>

 
    <a href="/2016/04/24/thread1/#comments" title="查看评论">
        <i class="fa fa-comments-o" aria-hidden="true"></i>
        <span class="count-comment"></span>
        
            <span class="ds-thread-count"  data-thread-key="2016/04/24/thread1/" ></span>
        
        
    </a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/24/thread1/">Java多线程干货系列—（一）Java多线程基础</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>多线程并发编程是Java编程中重要的一块内容，也是面试重点覆盖区域，所以学好多线程并发编程对我们来说极其重要，下面跟我一起开启本次的学习之旅吧。</p>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="线程与进程"><a href="#线程与进程" class="headerlink" title="线程与进程"></a>线程与进程</h2><p>1 线程：进程中负责程序执行的执行单元<br>线程本身依靠程序进行运行<br>线程是程序中的顺序控制流，只能使用分配给程序的资源和环境</p>
<p>2 进程：执行中的程序<br>一个进程至少包含一个线程</p>
<p>3 单线程：程序中只存在一个线程，实际上主方法就是一个主线程</p>
<p>4 多线程：在一个程序中运行多个任务<br>目的是更好地使用CPU资源</p>
<h2 id="线程的实现"><a href="#线程的实现" class="headerlink" title="线程的实现"></a>线程的实现</h2><h3 id="继承Thread类"><a href="#继承Thread类" class="headerlink" title="继承Thread类"></a>继承<code>Thread</code>类</h3><p>在<code>java.lang</code>包中定义, 继承Thread类必须重写<code>run()</code>方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyThread</span><span class="params">()</span></span>&#123;</span><br><span class="line">        num++;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"主动创建的第"</span>+num+<span class="string">"个线程"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>创建好了自己的线程类之后，就可以创建线程对象了，然后通过start()方法去启动线程。注意，不是调用run()方法启动线程，run方法中只是定义需要执行的任务，如果调用run方法，即相当于在主线程中执行run方法，跟普通的方法调用没有任何区别，此时并不会创建一个新的线程来执行定义的任务。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span>&#123;</span><br><span class="line">        MyThread thread = <span class="keyword">new</span> MyThread();</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyThread</span><span class="params">()</span></span>&#123;</span><br><span class="line">        num++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"主动创建的第"</span>+num+<span class="string">"个线程"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面代码中，通过调用start()方法，就会创建一个新的线程了。为了分清start()方法调用和run()方法调用的区别，请看下面一个例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"主线程ID:"</span>+Thread.currentThread().getId());</span><br><span class="line">        MyThread thread1 = <span class="keyword">new</span> MyThread(<span class="string">"thread1"</span>);</span><br><span class="line">        thread1.start();</span><br><span class="line">        MyThread thread2 = <span class="keyword">new</span> MyThread(<span class="string">"thread2"</span>);</span><br><span class="line">        thread2.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyThread</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"name:"</span>+name+<span class="string">" 子线程ID:"</span>+Thread.currentThread().getId());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行结果：<br><img src="http://7xqch5.com1.z0.glb.clouddn.com/thread1_1.jpg" alt=""></p>
<p>从输出结果可以得出以下结论：</p>
<p>1）thread1和thread2的线程ID不同，thread2和主线程ID相同，说明通过run方法调用并不会创建新的线程，而是在主线程中直接运行run方法，跟普通的方法调用没有任何区别；</p>
<p>2）虽然thread1的start方法调用在thread2的run方法前面调用，但是先输出的是thread2的run方法调用的相关信息，说明新线程创建的过程不会阻塞主线程的后续执行。</p>
<h3 id="实现Runnable接口"><a href="#实现Runnable接口" class="headerlink" title="实现Runnable接口"></a>实现<code>Runnable</code>接口</h3><p>在Java中创建线程除了继承Thread类之外，还可以通过实现Runnable接口来实现类似的功能。实现Runnable接口必须重写其run方法。<br>下面是一个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"主线程ID："</span>+Thread.currentThread().getId());</span><br><span class="line">        MyRunnable runnable = <span class="keyword">new</span> MyRunnable();</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(runnable);</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyRunnable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"子线程ID："</span>+Thread.currentThread().getId());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Runnable的中文意思是“任务”，顾名思义，通过实现Runnable接口，我们定义了一个子任务，然后将子任务交由Thread去执行。注意，这种方式必须将Runnable作为Thread类的参数，然后通过Thread的start方法来创建一个新线程来执行该子任务。如果调用Runnable的run方法的话，是不会创建新线程的，这根普通的方法调用没有任何区别。<br>事实上，查看Thread类的实现源代码会发现Thread类是实现了Runnable接口的。<br>在Java中，这2种方式都可以用来创建线程去执行子任务，具体选择哪一种方式要看自己的需求。直接继承Thread类的话，可能比实现Runnable接口看起来更加简洁，但是由于Java只允许单继承，所以如果自定义类需要继承其他类，则只能选择实现Runnable接口。</p>
<h3 id="使用ExecutorService、Callable、Future实现有返回结果的多线程"><a href="#使用ExecutorService、Callable、Future实现有返回结果的多线程" class="headerlink" title="使用ExecutorService、Callable、Future实现有返回结果的多线程"></a>使用ExecutorService、Callable、Future实现有返回结果的多线程</h3><p>多线程后续会学到，这里暂时先知道一下有这种方法即可。<br>ExecutorService、Callable、Future这个对象实际上都是属于Executor框架中的功能类。想要详细了解Executor框架的可以访问<a href="http://www.javaeye.com/topic/366591" target="_blank" rel="external">http://www.javaeye.com/topic/366591</a> ，这里面对该框架做了很详细的解释。返回结果的线程是在JDK1.5中引入的新特征，确实很实用，有了这种特征我就不需要再为了得到返回值而大费周折了，而且即便实现了也可能漏洞百出。<br>可返回值的任务必须实现Callable接口，类似的，无返回值的任务必须Runnable接口。执行Callable任务后，可以获取一个Future的对象，在该对象上调用get就可以获取到Callable任务返回的Object了，再结合线程池接口ExecutorService就可以实现传说中有返回结果的多线程了。下面提供了一个完整的有返回结果的多线程测试例子，在JDK1.5下验证过没问题可以直接使用。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* 有返回值的线程 </span><br><span class="line">*/</span>  </span><br><span class="line"><span class="annotation">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException,  </span><br><span class="line">    InterruptedException </span>&#123;  </span><br><span class="line">   System.out.println(<span class="string">"----程序开始运行----"</span>);  </span><br><span class="line">   Date date1 = <span class="keyword">new</span> Date();  </span><br><span class="line">  </span><br><span class="line">   <span class="keyword">int</span> taskSize = <span class="number">5</span>;  </span><br><span class="line">   <span class="comment">// 创建一个线程池  </span></span><br><span class="line">   ExecutorService pool = Executors.newFixedThreadPool(taskSize);  </span><br><span class="line">   <span class="comment">// 创建多个有返回值的任务  </span></span><br><span class="line">   List&lt;Future&gt; list = <span class="keyword">new</span> ArrayList&lt;Future&gt;();  </span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; taskSize; i++) &#123;  </span><br><span class="line">    Callable c = <span class="keyword">new</span> MyCallable(i + <span class="string">" "</span>);  </span><br><span class="line">    <span class="comment">// 执行任务并获取Future对象  </span></span><br><span class="line">    Future f = pool.submit(c);  </span><br><span class="line">    <span class="comment">// System.out.println("&gt;&gt;&gt;" + f.get().toString());  </span></span><br><span class="line">    list.add(f);  </span><br><span class="line">   &#125;  </span><br><span class="line">   <span class="comment">// 关闭线程池  </span></span><br><span class="line">   pool.shutdown();  </span><br><span class="line">  </span><br><span class="line">   <span class="comment">// 获取所有并发任务的运行结果  </span></span><br><span class="line">   <span class="keyword">for</span> (Future f : list) &#123;  </span><br><span class="line">    <span class="comment">// 从Future对象上获取任务的返回值，并输出到控制台  </span></span><br><span class="line">    System.out.println(<span class="string">"&gt;&gt;&gt;"</span> + f.get().toString());  </span><br><span class="line">   &#125;  </span><br><span class="line">  </span><br><span class="line">   Date date2 = <span class="keyword">new</span> Date();  </span><br><span class="line">   System.out.println(<span class="string">"----程序结束运行----，程序运行时间【"</span>  </span><br><span class="line">     + (date2.getTime() - date1.getTime()) + <span class="string">"毫秒】"</span>);  </span><br><span class="line">&#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCallable</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Object</span>&gt; </span>&#123;  </span><br><span class="line"><span class="keyword">private</span> String taskNum;  </span><br><span class="line">  </span><br><span class="line">MyCallable(String taskNum) &#123;  </span><br><span class="line">   <span class="keyword">this</span>.taskNum = taskNum;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;  </span><br><span class="line">   System.out.println(<span class="string">"&gt;&gt;&gt;"</span> + taskNum + <span class="string">"任务启动"</span>);  </span><br><span class="line">   Date dateTmp1 = <span class="keyword">new</span> Date();  </span><br><span class="line">   Thread.sleep(<span class="number">1000</span>);  </span><br><span class="line">   Date dateTmp2 = <span class="keyword">new</span> Date();  </span><br><span class="line">   <span class="keyword">long</span> time = dateTmp2.getTime() - dateTmp1.getTime();  </span><br><span class="line">   System.out.println(<span class="string">"&gt;&gt;&gt;"</span> + taskNum + <span class="string">"任务终止"</span>);  </span><br><span class="line">   <span class="keyword">return</span> taskNum + <span class="string">"任务返回运行结果,当前任务时间【"</span> + time + <span class="string">"毫秒】"</span>;  </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码说明：<br>上述代码中Executors类，提供了一系列工厂方法用于创先线程池，返回的线程池都实现了ExecutorService接口。<br>public static ExecutorService newFixedThreadPool(int nThreads)<br>创建固定数目线程的线程池。</p>
<p>public static ExecutorService newCachedThreadPool()<br>创建一个可缓存的线程池，调用execute 将重用以前构造的线程（如果线程可用）。如果现有线程没有可用的，则创建一个新线程并添加到池中。终止并从缓存中移除那些已有 60 秒钟未被使用的线程。</p>
<p>public static ExecutorService newSingleThreadExecutor()<br>创建一个单线程化的Executor。</p>
<p>public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize)<br>创建一个支持定时及周期性的任务执行的线程池，多数情况下可用来替代Timer类。</p>
<p>ExecutoreService提供了submit()方法，传递一个Callable，或Runnable，返回Future。如果Executor后台线程池还没有完成Callable的计算，这调用返回Future对象的get()方法，会阻塞直到计算完成。</p>
<h2 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h2><p>在正式学习Thread类中的具体方法之前，我们先来了解一下线程有哪些状态，这个将会有助于后面对Thread类中的方法的理解。</p>
<ul>
<li>创建（new）状态: 准备好了一个多线程的对象</li>
<li>就绪（runnable）状态: 调用了<code>start()</code>方法, 等待CPU进行调度</li>
<li>运行（running）状态: 执行<code>run()</code>方法</li>
<li>阻塞（blocked）状态: 暂时停止执行, 可能将资源交给其它线程使用</li>
<li>终止（dead）状态: 线程销毁</li>
</ul>
<p>当需要新起一个线程来执行某个子任务时，就创建了一个线程。但是线程创建之后，不会立即进入就绪状态，因为线程的运行需要一些条件（比如内存资源，在前面的JVM内存区域划分一篇博文中知道程序计数器、Java栈、本地方法栈都是线程私有的，所以需要为线程分配一定的内存空间），只有线程运行需要的所有条件满足了，才进入就绪状态。</p>
<p>当线程进入就绪状态后，不代表立刻就能获取CPU执行时间，也许此时CPU正在执行其他的事情，因此它要等待。当得到CPU执行时间之后，线程便真正进入运行状态。</p>
<p>线程在运行状态过程中，可能有多个原因导致当前线程不继续运行下去，比如用户主动让线程睡眠（睡眠一定的时间之后再重新执行）、用户主动让线程等待，或者被同步块给阻塞，此时就对应着多个状态：time waiting（睡眠或等待一定的事件）、waiting（等待被唤醒）、blocked（阻塞）。</p>
<p>当由于突然中断或者子任务执行完毕，线程就会被消亡。</p>
<p>下面这副图描述了线程从创建到消亡之间的状态：<br><img src="http://7xqch5.com1.z0.glb.clouddn.com/thread1_2.jpg" alt=""></p>
<p>在有些教程上将blocked、waiting、time waiting统称为阻塞状态，这个也是可以的，只不过这里我想将线程的状态和Java中的方法调用联系起来，所以将waiting和time waiting两个状态分离出来。</p>
<p>注:sleep和wait的区别:</p>
<blockquote>
<ul>
<li><code>sleep</code>是<code>Thread</code>类的方法,<code>wait</code>是<code>Object</code>类中定义的方法.</li>
<li><code>Thread.sleep</code>不会导致锁行为的改变, 如果当前线程是拥有锁的, 那么<code>Thread.sleep</code>不会让线程释放锁.</li>
<li><code>Thread.sleep</code>和<code>Object.wait</code>都会暂停当前的线程. OS会将执行时间分配给其它线程. 区别是, 调用<code>wait</code>后, 需要别的线程执行<code>notify/notifyAll</code>才能够重新获得CPU执行时间.</li>
</ul>
</blockquote>
<h2 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h2><p>对于单核CPU来说（对于多核CPU，此处就理解为一个核），CPU在一个时刻只能运行一个线程，当在运行一个线程的过程中转去运行另外一个线程，这个叫做线程上下文切换（对于进程也是类似）。</p>
<p>由于可能当前线程的任务并没有执行完毕，所以在切换时需要保存线程的运行状态，以便下次重新切换回来时能够继续切换之前的状态运行。举个简单的例子：比如一个线程A正在读取一个文件的内容，正读到文件的一半，此时需要暂停线程A，转去执行线程B，当再次切换回来执行线程A的时候，我们不希望线程A又从文件的开头来读取。</p>
<p>因此需要记录线程A的运行状态，那么会记录哪些数据呢？因为下次恢复时需要知道在这之前当前线程已经执行到哪条指令了，所以需要记录程序计数器的值，另外比如说线程正在进行某个计算的时候被挂起了，那么下次继续执行的时候需要知道之前挂起时变量的值时多少，因此需要记录CPU寄存器的状态。所以一般来说，线程上下文切换过程中会记录程序计数器、CPU寄存器状态等数据。</p>
<p>说简单点的：对于线程的上下文切换实际上就是 <strong>存储和恢复CPU状态的过程，它使得线程执行能够从中断点恢复执行</strong>。</p>
<p>虽然多线程可以使得任务执行的效率得到提升，但是由于在线程切换时同样会带来一定的开销代价，并且多个线程会导致系统资源占用的增加，所以在进行多线程编程时要注意这些因素。</p>
<h2 id="线程的常用方法"><a href="#线程的常用方法" class="headerlink" title="线程的常用方法"></a>线程的常用方法</h2><table>
<thead>
<tr>
<th>编号</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td><code>public void start()</code></td>
<td>使该线程开始执行；Java 虚拟机调用该线程的 run 方法。</td>
</tr>
<tr>
<td>2</td>
<td><code>public void run()</code></td>
<td>如果该线程是使用独立的 Runnable 运行对象构造的，则调用该 Runnable 对象的 run 方法；否则，该方法不执行任何操作并返回。</td>
</tr>
<tr>
<td>3</td>
<td><code>public final void setName(String name)</code></td>
<td>改变线程名称，使之与参数 name 相同。</td>
</tr>
<tr>
<td>4</td>
<td><code>public final void setPriority(int priority)</code></td>
<td>更改线程的优先级。</td>
</tr>
<tr>
<td>5</td>
<td><code>public final void setDaemon(boolean on)</code></td>
<td>将该线程标记为守护线程或用户线程。</td>
</tr>
<tr>
<td>6</td>
<td><code>public final void join(long millisec)</code></td>
<td>等待该线程终止的时间最长为 millis 毫秒。</td>
</tr>
<tr>
<td>7</td>
<td><code>public void interrupt()</code></td>
<td>中断线程。</td>
</tr>
<tr>
<td>8</td>
<td><code>public final boolean isAlive()</code></td>
<td>测试线程是否处于活动状态。</td>
</tr>
<tr>
<td>9</td>
<td><code>public static void yield()</code></td>
<td>暂停当前正在执行的线程对象，并执行其他线程。</td>
</tr>
<tr>
<td>10</td>
<td><code>public static void sleep(long millisec)</code></td>
<td>在指定的毫秒数内让当前正在执行的线程休眠（暂停执行），此操作受到系统计时器和调度程序精度和准确性的影响。</td>
</tr>
<tr>
<td>11</td>
<td><code>public static Thread currentThread()</code></td>
<td>返回对当前正在执行的线程对象的引用。</td>
</tr>
</tbody>
</table>
<p><img src="http://7xqch5.com1.z0.glb.clouddn.com/thread1_3.jpg" alt=""></p>
<h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><h3 id="currentThread-方法"><a href="#currentThread-方法" class="headerlink" title="currentThread()方法"></a>currentThread()方法</h3><p>currentThread()方法可以返回代码段正在被哪个线程调用的信息。<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class Run1&#123;</span><br><span class="line">    public static void main(String[] args)&#123;                 </span><br><span class="line">    System.out.println(Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">### sleep()方法</span><br><span class="line">方法sleep()的作用是在指定的毫秒数内让当前“正在执行的线程”休眠（暂停执行）。这个“正在执行的线程”是指this.currentThread()返回的线程。</span><br><span class="line"></span><br><span class="line">sleep方法有两个重载版本：</span><br><span class="line"> ```java</span><br><span class="line">sleep(long millis)     //参数为毫秒</span><br><span class="line">sleep(long millis,int nanoseconds)    //第一参数为毫秒，第二个参数为纳秒</span><br></pre></td></tr></table></figure></p>
<p>sleep相当于让线程睡眠，交出CPU，让CPU去执行其他的任务。<br>但是有一点要非常注意，sleep方法不会释放锁，也就是说如果当前线程持有对某个对象的锁，则即使调用sleep方法，其他线程也无法访问这个对象。看下面这个例子就清楚了：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> Object object = <span class="keyword">new</span> Object();</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException  </span>&#123;</span><br><span class="line">        Test test = <span class="keyword">new</span> Test();</span><br><span class="line">        MyThread thread1 = test.new MyThread();</span><br><span class="line">        MyThread thread2 = test.new MyThread();</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125; </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">        <span class="annotation">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (object) &#123;</span><br><span class="line">                i++;</span><br><span class="line">                System.out.println(<span class="string">"i:"</span>+i);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">"线程"</span>+Thread.currentThread().getName()+<span class="string">"进入睡眠状态"</span>);</span><br><span class="line">                    Thread.currentThread().sleep(<span class="number">10000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">"线程"</span>+Thread.currentThread().getName()+<span class="string">"睡眠结束"</span>);</span><br><span class="line">                i++;</span><br><span class="line">                System.out.println(<span class="string">"i:"</span>+i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出结果：<br><img src="http://7xqch5.com1.z0.glb.clouddn.com/thread1_4.jpg" alt=""><br>从上面输出结果可以看出，当Thread-0进入睡眠状态之后，Thread-1并没有去执行具体的任务。只有当Thread-0执行完之后，此时Thread-0释放了对象锁，Thread-1才开始执行。</p>
<p>注意，如果调用了sleep方法，必须捕获InterruptedException异常或者将该异常向上层抛出。当线程睡眠时间满后，不一定会立即得到执行，因为此时可能CPU正在执行其他的任务。所以说调用sleep方法相当于让线程进入阻塞状态。</p>
<h3 id="yield-方法"><a href="#yield-方法" class="headerlink" title="yield()方法"></a>yield()方法</h3><p>调用yield方法会让当前线程交出CPU权限，让CPU去执行其他的线程。它跟sleep方法类似，同样不会释放锁。但是yield不能控制具体的交出CPU的时间，另外，yield方法只能让拥有相同优先级的线程有获取CPU执行时间的机会。</p>
<p>注意，调用yield方法并不会让线程进入阻塞状态，而是让线程重回就绪状态，它只需要等待重新获取CPU执行时间，这一点是和sleep方法不一样的。<br>代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span>  <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> beginTime=System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">50000000</span>;i++)&#123;</span><br><span class="line">            count=count+(i+<span class="number">1</span>);</span><br><span class="line">            <span class="comment">//Thread.yield();</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> endTime=System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"用时："</span>+(endTime-beginTime)+<span class="string">" 毫秒！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Run</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyThread t= <span class="keyword">new</span> MyThread();</span><br><span class="line">        t.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>执行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#29992;&#26102;&#65306;3 &#27627;&#31186;&#65281;</span><br></pre></td></tr></table></figure></p>
<p>如果将  <code>//Thread.yield();</code>的注释去掉，执行结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#29992;&#26102;&#65306;16080 &#27627;&#31186;&#65281;</span><br></pre></td></tr></table></figure></p>
<h3 id="对象方法"><a href="#对象方法" class="headerlink" title="对象方法"></a>对象方法</h3><h4 id="start-方法"><a href="#start-方法" class="headerlink" title="start()方法"></a>start()方法</h4><p>start()用来启动一个线程，当调用start方法后，系统才会开启一个新的线程来执行用户定义的子任务，在这个过程中，会为相应的线程分配需要的资源。  </p>
<h4 id="run-方法"><a href="#run-方法" class="headerlink" title="run()方法"></a>run()方法</h4><p>run()方法是不需要用户来调用的，当通过start方法启动一个线程之后，当线程获得了CPU执行时间，便进入run方法体去执行具体的任务。注意，继承Thread类必须重写run方法，在run方法中定义具体要执行的任务。  </p>
<h4 id="getId"><a href="#getId" class="headerlink" title="getId()"></a>getId()</h4><p>getId()的作用是取得线程的唯一标识<br>代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t= Thread.currentThread();</span><br><span class="line">        System.out.println(t.getName()+<span class="string">" "</span>+t.getId());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">main 1</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">#### isAlive()方法  </span><br><span class="line"></span><br><span class="line">方法isAlive()的功能是判断当前线程是否处于活动状态</span><br><span class="line">代码：</span><br><span class="line">```java</span><br><span class="line">public class MyThread  extends Thread&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        System.out.println("run="+this.isAlive());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class RunTest &#123;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        MyThread myThread=new MyThread();</span><br><span class="line">        System.out.println("begin =="+myThread.isAlive());</span><br><span class="line">        myThread.start();</span><br><span class="line">        System.out.println("end =="+myThread.isAlive());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>程序运行结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">begin ==<span class="keyword">false</span></span><br><span class="line">run=<span class="keyword">true</span></span><br><span class="line">end ==<span class="keyword">false</span></span><br></pre></td></tr></table></figure></p>
<p>方法isAlive()的作用是测试线程是否偶处于活动状态。什么是活动状态呢？活动状态就是线程已经启动且尚未终止。线程处于正在运行或准备开始运行的状态，就认为线程是“存活”的。<br>有个需要注意的地方<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">"end =="</span>+myThread.isAlive());</span><br></pre></td></tr></table></figure></p>
<p>虽然上面的实例中打印的值是true,但此值是不确定的。打印true值是因为myThread线程还未执行完毕，所以输出true。如果代码改成下面这样，加了个sleep休眠：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        MyThread myThread=<span class="keyword">new</span> MyThread();</span><br><span class="line">        System.out.println(<span class="string">"begin =="</span>+myThread.isAlive());</span><br><span class="line">        myThread.start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        System.out.println(<span class="string">"end =="</span>+myThread.isAlive());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>则上述代码运行的结果输出为false,因为mythread对象已经在1秒之内执行完毕。  </p>
<h4 id="join-方法"><a href="#join-方法" class="headerlink" title="join()方法"></a>join()方法</h4><p>在很多情况下，主线程创建并启动了线程，如果子线程中药进行大量耗时运算，主线程往往将早于子线程结束之前结束。这时，如果主线程想等待子线程执行完成之后再结束，比如子线程处理一个数据，主线程要取得这个数据中的值，就要用到join()方法了。方法join()的作用是等待线程对象销毁。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread4</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Thread4</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            System.out.println(getName() + <span class="string">"  "</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 启动子进程</span></span><br><span class="line">        <span class="keyword">new</span> Thread4(<span class="string">"new thread"</span>).start();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">5</span>) &#123;</span><br><span class="line">                Thread4 th = <span class="keyword">new</span> Thread4(<span class="string">"joined thread"</span>);</span><br><span class="line">                th.start();</span><br><span class="line">                th.join();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"  "</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>执行结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">main  <span class="number">0</span></span><br><span class="line">main  <span class="number">1</span></span><br><span class="line">main  <span class="number">2</span></span><br><span class="line">main  <span class="number">3</span></span><br><span class="line">main  <span class="number">4</span></span><br><span class="line"><span class="keyword">new</span> thread  <span class="number">0</span></span><br><span class="line"><span class="keyword">new</span> thread  <span class="number">1</span></span><br><span class="line"><span class="keyword">new</span> thread  <span class="number">2</span></span><br><span class="line"><span class="keyword">new</span> thread  <span class="number">3</span></span><br><span class="line"><span class="keyword">new</span> thread  <span class="number">4</span></span><br><span class="line">joined thread  <span class="number">0</span></span><br><span class="line">joined thread  <span class="number">1</span></span><br><span class="line">joined thread  <span class="number">2</span></span><br><span class="line">joined thread  <span class="number">3</span></span><br><span class="line">joined thread  <span class="number">4</span></span><br><span class="line">main  <span class="number">5</span></span><br><span class="line">main  <span class="number">6</span></span><br><span class="line">main  <span class="number">7</span></span><br><span class="line">main  <span class="number">8</span></span><br><span class="line">main  <span class="number">9</span></span><br></pre></td></tr></table></figure></p>
<p>由上可以看出main主线程等待joined thread线程先执行完了才结束的。如果把th.join()这行注释掉，运行结果如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">main  <span class="number">0</span></span><br><span class="line">main  <span class="number">1</span></span><br><span class="line">main  <span class="number">2</span></span><br><span class="line">main  <span class="number">3</span></span><br><span class="line">main  <span class="number">4</span></span><br><span class="line">main  <span class="number">5</span></span><br><span class="line">main  <span class="number">6</span></span><br><span class="line">main  <span class="number">7</span></span><br><span class="line">main  <span class="number">8</span></span><br><span class="line">main  <span class="number">9</span></span><br><span class="line"><span class="keyword">new</span> thread  <span class="number">0</span></span><br><span class="line"><span class="keyword">new</span> thread  <span class="number">1</span></span><br><span class="line"><span class="keyword">new</span> thread  <span class="number">2</span></span><br><span class="line"><span class="keyword">new</span> thread  <span class="number">3</span></span><br><span class="line"><span class="keyword">new</span> thread  <span class="number">4</span></span><br><span class="line">joined thread  <span class="number">0</span></span><br><span class="line">joined thread  <span class="number">1</span></span><br><span class="line">joined thread  <span class="number">2</span></span><br><span class="line">joined thread  <span class="number">3</span></span><br><span class="line">joined thread  <span class="number">4</span></span><br></pre></td></tr></table></figure></p>
<h4 id="getName和setName"><a href="#getName和setName" class="headerlink" title="getName和setName"></a>getName和setName</h4><p>用来得到或者设置线程名称。</p>
<h4 id="getPriority和setPriority"><a href="#getPriority和setPriority" class="headerlink" title="getPriority和setPriority"></a>getPriority和setPriority</h4><p>用来获取和设置线程优先级。</p>
<h4 id="setDaemon和isDaemon"><a href="#setDaemon和isDaemon" class="headerlink" title="setDaemon和isDaemon"></a>setDaemon和isDaemon</h4><p>用来设置线程是否成为守护线程和判断线程是否是守护线程。</p>
<p>守护线程和用户线程的区别在于：守护线程依赖于创建它的线程，而用户线程则不依赖。举个简单的例子：如果在main线程中创建了一个守护线程，当main方法运行完毕之后，守护线程也会随着消亡。而用户线程则不会，用户线程会一直运行直到其运行完毕。在JVM中，像垃圾收集器线程就是守护线程。</p>
<p><strong>在上面已经说到了Thread类中的大部分方法，那么Thread类中的方法调用到底会引起线程状态发生怎样的变化呢？下面一幅图就是在上面的图上进行改进而来的：</strong></p>
<p><img src="http://7xqch5.com1.z0.glb.clouddn.com/thread1_5.jpg" alt=""></p>
<h2 id="停止线程"><a href="#停止线程" class="headerlink" title="停止线程"></a>停止线程</h2><p>停止线程是在多线程开发时很重要的技术点，掌握此技术可以对线程的停止进行有效的处理。<br>停止一个线程可以使用Thread.stop()方法，但最好不用它。该方法是不安全的，已被弃用。<br>在Java中有以下3种方法可以终止正在运行的线程：</p>
<ul>
<li>使用退出标志，使线程正常退出，也就是当run方法完成后线程终止</li>
<li>使用stop方法强行终止线程，但是不推荐使用这个方法，因为stop和suspend及resume一样，都是作废过期的方法，使用他们可能产生不可预料的结果。</li>
<li>使用interrupt方法中断线程，但这个不会终止一个正在运行的线程，还需要加入一个判断才可以完成线程的停止。</li>
</ul>
<h2 id="暂停线程"><a href="#暂停线程" class="headerlink" title="暂停线程"></a>暂停线程</h2><p>interrupt()方法</p>
<h2 id="线程的优先级"><a href="#线程的优先级" class="headerlink" title="线程的优先级"></a>线程的优先级</h2><p>在操作系统中，线程可以划分优先级，优先级较高的线程得到的CPU资源较多，也就是CPU优先执行优先级较高的线程对象中的任务。<br>设置线程优先级有助于帮“线程规划器”确定在下一次选择哪一个线程来优先执行。<br>设置线程的优先级使用setPriority()方法，此方法在JDK的源码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setPriority</span><span class="params">(<span class="keyword">int</span> newPriority)</span> </span>&#123;</span><br><span class="line">        ThreadGroup g;</span><br><span class="line">        checkAccess();</span><br><span class="line">        <span class="keyword">if</span> (newPriority &gt; MAX_PRIORITY || newPriority &lt; MIN_PRIORITY) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>((g = getThreadGroup()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (newPriority &gt; g.getMaxPriority()) &#123;</span><br><span class="line">                newPriority = g.getMaxPriority();</span><br><span class="line">            &#125;</span><br><span class="line">            setPriority0(priority = newPriority);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>在Java中，线程的优先级分为1~10这10个等级，如果小于1或大于10，则JDK抛出异常throw new IllegalArgumentException()。<br>JDK中使用3个常量来预置定义优先级的值，代码如下：<br>public final static int MIN_PRIORITY = 1;<br>public final static int NORM_PRIORITY = 5;<br>public final static int MAX_PRIORITY = 10;</p>
<p>线程优先级特性：</p>
<ul>
<li>继承性<br>比如A线程启动B线程，则B线程的优先级与A是一样的。</li>
<li>规则性<br>高优先级的线程总是大部分先执行完，但不代表高优先级线程全部先执行完。</li>
<li>随机性<br>优先级较高的线程不一定每一次都先执行完。</li>
</ul>
<h2 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h2><p>在Java线程中有两种线程，一种是User Thread（用户线程），另一种是Daemon Thread(守护线程)。<br>Daemon的作用是为其他线程的运行提供服务，比如说GC线程。其实User Thread线程和Daemon Thread守护线程本质上来说去没啥区别的，唯一的区别之处就在虚拟机的离开：如果User Thread全部撤离，那么Daemon Thread也就没啥线程好服务的了，所以虚拟机也就退出了。</p>
<p>守护线程并非虚拟机内部可以提供，用户也可以自行的设定守护线程，方法：public final void setDaemon(boolean on) ；但是有几点需要注意：</p>
<ul>
<li><p>thread.setDaemon(true)必须在thread.start()之前设置，否则会跑出一个IllegalThreadStateException异常。你不能把正在运行的常规线程设置为守护线程。  （备注：这点与守护进程有着明显的区别，守护进程是创建后，让进程摆脱原会话的控制+让进程摆脱原进程组的控制+让进程摆脱原控制终端的控制；所以说寄托于虚拟机的语言机制跟系统级语言有着本质上面的区别）</p>
</li>
<li><p>在Daemon线程中产生的新线程也是Daemon的。  （这一点又是有着本质的区别了：守护进程fork()出来的子进程不再是守护进程，尽管它把父进程的进程相关信息复制过去了，但是子进程的进程的父进程不是init进程，所谓的守护进程本质上说就是“父进程挂掉，init收养，然后文件0,1,2都是/dev/null，当前目录到/”）</p>
</li>
<li><p>不是所有的应用都可以分配给Daemon线程来进行服务，比如读写操作或者计算逻辑。因为在Daemon Thread还没来的及进行操作时，虚拟机可能已经退出了。</p>
</li>
</ul>
<h3 id="同步与死锁"><a href="#同步与死锁" class="headerlink" title="同步与死锁"></a>同步与死锁</h3><ol>
<li><p>同步代码块<br>在代码块上加上”synchronized”关键字，则此代码块就称为同步代码块</p>
</li>
<li><p>同步代码块格式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(同步对象)&#123;</span><br><span class="line">    需要同步的代码块;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>同步方法<br>除了代码块可以同步，方法也是可以同步的</p>
</li>
<li>方法同步格式<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> <span class="keyword">void</span> 方法名称()&#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>synchronized后续会单独来学习。(●’◡’●)</p>
<h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><p><strong>线程和进程有什么区别？</strong><br>答：一个进程是一个独立(self contained)的运行环境，它可以被看作一个程序或者一个应用。而线程是在进程中执行的一个任务。线程是进程的子集，一个进程可以有很多线程，每条线程并行执行不同的任务。不同的进程使用不同的内存空间，而所有的线程共享一片相同的内存空间。别把它和栈内存搞混，每个线程都拥有单独的栈内存用来存储本地数据。</p>
<p><strong>如何在Java中实现线程？</strong><br>答：<br>创建线程有两种方式：<br>一、继承 Thread 类，扩展线程。<br>二、实现 Runnable 接口。</p>
<p><strong>启动一个线程是调用run()还是start()方法？</strong><br>答：启动一个线程是调用start()方法，使线程所代表的虚拟处理机处于可运行状态，这意味着它可以由JVM 调度并执行，这并不意味着线程就会立即运行。run()方法是线程启动后要进行回调（callback）的方法。</p>
<p><strong>Thread类的sleep()方法和对象的wait()方法都可以让线程暂停执行，它们有什么区别?</strong><br>答：sleep()方法（休眠）是线程类（Thread）的静态方法，调用此方法会让当前线程暂停执行指定的时间，将执行机会（CPU）让给其他线程，但是对象的锁依然保持，因此休眠时间结束后会自动恢复（线程回到就绪状态，请参考第66题中的线程状态转换图）。wait()是Object类的方法，调用对象的wait()方法导致当前线程放弃对象的锁（线程暂停执行），进入对象的等待池（wait pool），只有调用对象的notify()方法（或notifyAll()方法）时才能唤醒等待池中的线程进入等锁池（lock pool），如果线程重新获得对象的锁就可以进入就绪状态。</p>
<p><strong>线程的sleep()方法和yield()方法有什么区别？</strong><br>答：<br>① sleep()方法给其他线程运行机会时不考虑线程的优先级，因此会给低优先级的线程以运行的机会；yield()方法只会给相同优先级或更高优先级的线程以运行的机会；<br>② 线程执行sleep()方法后转入阻塞（blocked）状态，而执行yield()方法后转入就绪（ready）状态；<br>③ sleep()方法声明抛出InterruptedException，而yield()方法没有声明任何异常；<br>④ sleep()方法比yield()方法（跟操作系统CPU调度相关）具有更好的可移植性。</p>
<p><strong>请说出与线程同步以及线程调度相关的方法。</strong><br>答： </p>
<ul>
<li>wait()：使一个线程处于等待（阻塞）状态，并且释放所持有的对象的锁； </li>
<li>sleep()：使一个正在运行的线程处于睡眠状态，是一个静态方法，调用此方法要处理InterruptedException异常； </li>
<li>notify()：唤醒一个处于等待状态的线程，当然在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，而是由JVM确定唤醒哪个线程，而且与优先级无关； </li>
<li>notityAll()：唤醒所有处于等待状态的线程，该方法并不是将对象的锁给所有线程，而是让它们竞争，只有获得锁的线程才能进入就绪状态；</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>以上就是多线程的一些基础概念，可能总结的不够仔细，多多包涵。后续会针对一些比较重要的知识点单独列出来总结。学好多线程是拿高薪的基础，小伙伴一起加油吧！</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>该文为本人学习的笔记，方便以后自己跳槽前复习。参考网上各大帖子，取其精华整合自己的理解而成。还有，关注我个人主页的公众号，里面电子书资源有《Java多线程编程核心技术》以及《JAVA并发编程实践》高清版，需要的小伙伴自己取。</p>
<p>《Java多线程编程核心技术》<br>《JAVA并发编程实践》<br><a href="http://www.cnblogs.com/dolphin0520/p/3920357.html" target="_blank" rel="external">Java并发编程：Thread类的使用</a><br><a href="http://blog.csdn.net/jackfrued/article/details/44499227" target="_blank" rel="external">关于Java并发编程的总结和思考</a><br><a href="http://blog.csdn.net/aboy123/article/details/38307539" target="_blank" rel="external">JAVA多线程实现的三种方式</a></p>
<h1 id="整理的思维导图"><a href="#整理的思维导图" class="headerlink" title="整理的思维导图"></a>整理的思维导图</h1><p>个人整理的多线程基础的思维导图,导出的图片无法查看备注的一些信息，所以需要源文件的童鞋可以关注我个人主页上的公众号，回复<strong>多线程基础</strong>即可获取源文件。<br><img src="http://7xqch5.com1.z0.glb.clouddn.com/thread1.png" alt=""></p>
<hr>
<p> 博主弄了个java学习资源的公众号，学习资源超级多，视频，电子书，最新开发工具一个都不能少，已全部分享到百度云盘，求资源共享，打造一个学习方便，工作方便的java公众号，开源开源，有需求的可以关注~撒花<br> <img src="http://7xqch5.com1.z0.glb.clouddn.com/javaLearn.PNG" alt=""></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Java多线程/">Java多线程</a>
    </div>


      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-sjms7adapter" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/04/17/sjms7adapter/" class="article-date">
      <time datetime="2016-04-17T06:45:08.000Z" itemprop="datePublished">2016-04-17</time>
</a>

 
    <a href="/2016/04/17/sjms7adapter/#comments" title="查看评论">
        <i class="fa fa-comments-o" aria-hidden="true"></i>
        <span class="count-comment"></span>
        
            <span class="ds-thread-count"  data-thread-key="2016/04/17/sjms7adapter/" ></span>
        
        
    </a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/17/sjms7adapter/">设计模式干货系列：（七）适配器模式【学习难度：★★☆☆☆，使用频率：★★★★☆】</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>今天介绍适配器模式，举个生活中的例子，我们笔记本用到的充电器其实就是个适配器，笔记本电脑的工作电压是20V，而我国的家庭用电是220V，如何让20V的笔记本电脑能够在220V的电压下工作？就是靠这个充电器搞定的。</p>
<p>在软件开发中，有时也存在类似这种不兼容的情况，我们也可以像引入一个电源适配器一样引入一个称之为适配器的角色来协调这些存在不兼容的结构，这种设计方案即为适配器模式。</p>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="适配器模式概念"><a href="#适配器模式概念" class="headerlink" title="适配器模式概念"></a>适配器模式概念</h2><p>适配器模式(Adapter Pattern)：将一个接口转换成客户希望的另一个接口，使接口不兼容的那些类可以一起工作，其别名为包装器(Wrapper)。适配器模式既可以作为类结构型模式，也可以作为对象结构型模式。</p>
<h2 id="适配器模式结构图"><a href="#适配器模式结构图" class="headerlink" title="适配器模式结构图"></a>适配器模式结构图</h2><p>适配器模式有类适配器模式和对象的适配器模式两种不同的形式。如下图所示，左边是的类的适配器模式（继承），右边是对象的适配器模式（引用）。<br><img src="http://7xqch5.com1.z0.glb.clouddn.com/sjms7_1.png" alt=""></p>
<h3 id="类的适配器模式"><a href="#类的适配器模式" class="headerlink" title="类的适配器模式"></a>类的适配器模式</h3><p>类的适配器模式把被适配的类的API转换成目标类的API，其静态结构图如下所示。<br><img src="http://7xqch5.com1.z0.glb.clouddn.com/sjms7_2.png" alt=""><br>在上图中可以看出，Adaptee类并没有simpleOperation2()方法，而客户端则期待这个方法。为使客户端能够使用Adaptee类，提供一个中间环节，即类Adapter，把Adaptee的API与Target类的API衔接起来。Adapter与Adaptee是继承关系，这决定了这个适配器模式是类的。</p>
<p>模式所涉及的角色有：</p>
<ul>
<li>目标（Target）角色：这就是所期待得到的接口。注意，由于这里讨论的是类适配器模式，因此目标不可以是类。</li>
<li>源（Adaptee）角色：现有需要配置的接口。</li>
<li>适配器（Adapter）角色：适配器类是本模式的核心。适配器把源接口转换成目标接口。显然，这一叫色不可以是接口，而必须是具体类。</li>
</ul>
<h3 id="对象的适配器模式"><a href="#对象的适配器模式" class="headerlink" title="对象的适配器模式"></a>对象的适配器模式</h3><p>与类的适配器模式一样，对象的适配器模式把被适配的类的API转换成目标类的API，与类的适配器模式不同的是，对象的适配器模式不是使用继承关系连接到Adaptee类，而是使用委派关系连接到Adaptee类。对象的适配器模式的静态结构如下图所示。<br><img src="http://7xqch5.com1.z0.glb.clouddn.com/sjms7_3.png" alt=""><br>从上图中可以看出，Adaptee类并没有simpleOperation2()方法，而客户端则期待这个方法。为使客户端能够使用Adaptee类，需要提供一个包装（Wrapper）类Adapter。这个包装类包装了一个Adaptee的实例，从而此包装类能够把Adaptee的API与Target类的API衔接起来。Adapter与Adaptee是委派关系，这决定了这个适配器模式是对象的。<br>从上图可以看出，模式所涉及的角色有：</p>
<ul>
<li>目标（Target）角色：这就是所期待的接口，目标可以是具体的或抽象的类。</li>
<li>源（Adaptee）角色：现有需要适配的接口。</li>
<li>适配器（Adapter）角色：适配器类是本模式的核心。适配器把源接口转换成目标接口，显然，这一角色必须是具体类。</li>
</ul>
<h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><h3 id="类的适配器模式代码"><a href="#类的适配器模式代码" class="headerlink" title="类的适配器模式代码"></a>类的适配器模式代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Target</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 这是源类也有的方法simpleOperation1</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">simpleOperation1</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 这是源类没有的方法simpleOperation2</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">simpleOperation2</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面给出的是目标角色的源代码，这个角色是以一个Java接口的形式实现的。可以看出，这个接口声明了两个方法：simpleOperation1()和simpleOperation2()。而源角色Adatpee是一个具体类，它有一个simpleOperation1()方法，但是没有simpleOperation2()方法，如下面代码清单所示。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adaptee</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 源类含有方法simpleOperation1</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">simpleOperation1</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>适配器角色Adapter扩展了Adaptee,同时又实现了目标接口。由于Adaptee没有提供simpleOperation2()方法，而目标接口又要求这个方法，因此适配器角色Adatper实现了这个方法，如下面代码清单所示。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adapter</span> <span class="keyword">extends</span> <span class="title">Adaptee</span> <span class="keyword">implements</span> <span class="title">Target</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 由于源类没有方法simpleOperation2</span><br><span class="line">     * 因此适配器类补充上这个方法</span><br><span class="line">     */</span></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">simpleOperation2</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>类的适配器模式的效果</strong>：</p>
<ul>
<li>使用一个具体类把源（Adaptee）适配到目标（Target）中。这样一来，如果源以及源的子类都使用此类适配，就行不通了。</li>
<li>由于适配器类是源的子类，因此可以适配器类中之换掉（Override）源的一些方法。</li>
<li>由于只引进了一个适配器类，因此只有一个路线到目标类，使问题得到简化。</li>
</ul>
<h3 id="对象的适配器模式代码"><a href="#对象的适配器模式代码" class="headerlink" title="对象的适配器模式代码"></a>对象的适配器模式代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Target</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 这是源类也有的方法simpleOperation1</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">simpleOperation1</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 这是源类没有的方法simpleOperation2</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">simpleOperation2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面给出的是目标角色的源代码，这个角色是以一个Java接口的形式实现的。可以看出，这个接口声明了两个方法：simpleOperation1()和simpleOperation2()。而源角色Adapatee是一个具体类，它有一个simpleOperation1()方法，但是没有simpleOperation2()方法，如下面带入清单所示。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adaptee</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 源类含有方法simpleOperation1</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">simpleOperation1</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>适配器类的源代码如下面代码清单所示。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adapter</span> <span class="keyword">implements</span> <span class="title">Target</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Adaptee adaptee;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Adapter</span><span class="params">(Adaptee adaptee)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.adaptee = adaptee;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 源类有方法simpleOperation1</span><br><span class="line">     * 因此适配器类直接委派即可</span><br><span class="line">     */</span></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">simpleOperation1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        adaptee.simpleOperation1();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 源类没有方法simpleOperation2</span><br><span class="line">     * 因此适配器类补充上这个方法</span><br><span class="line">     */</span></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">simpleOperation2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//write you code here</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>对象的适配器模式的效果</strong>：</p>
<ul>
<li>一个适配器可以把多种不同的源适配到同一个目标。换言之，同一个适配器可以把源类和它的子类都适配到目标接口。</li>
<li>与类的适配器模式相比，要想置换源类的方法就不容易。如果一定要置换掉源类的一个或多个方法，就只好先做一个源类的子类，将源类的方法置换掉，然后再把源类的子类当作真正的源进行适配。</li>
<li>虽然想要置换源类的方法不容易，但是要想增加一些新的方法则方便得很，而且新增加的方法可同时适用于所有的源。</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>适配器模式将现有接口转化为客户类所期望的接口，实现了对现有类的复用，它是一种使用频率非常高的设计模式，在软件开发中得以广泛应用，在Spring等开源框架、驱动程序设计（如JDBC中的数据库驱动程序）中也使用了适配器模式。<br><strong> 1. 主要优点</strong><br>无论是对象适配器模式还是类适配器模式都具有如下优点：</p>
<ul>
<li><strong>将目标类和适配者类解耦</strong>，通过引入一个适配器类来重用现有的适配者类，无须修改原有结构。</li>
<li><strong>增加了类的透明性和复用性</strong>，将具体的业务实现过程封装在适配者类中，对于客户端类而言是透明的，而且提高了适配者的复用性，同一个适配者类可以在多个不同的系统中复用。</li>
<li><strong>灵活性和扩展性都非常好</strong>，通过使用配置文件，可以很方便地更换适配器，也可以在不修改原有代码的基础上增加新的适配器类，完全符合“开闭原则”。</li>
</ul>
<p>具体来说，类适配器模式还有如下优点：</p>
<ul>
<li>由于适配器类是适配者类的子类，因此<strong>可以在适配器类中置换一些适配者的方法</strong>，使得适配器的灵活性更强。</li>
</ul>
<p>对象适配器模式还有如下优点：</p>
<ul>
<li>一个对象适配器<strong>可以把多个不同的适配者适配到同一个目标</strong>；</li>
<li><strong>可以适配一个适配者的子类</strong>，由于适配器和适配者之间是关联关系，根据“里氏代换原则”，适配者的子类也可通过该适配器进行适配。</li>
</ul>
<p><strong> 2. 主要缺点</strong><br><strong>类适配器模式</strong>的缺点如下：</p>
<ul>
<li>对于Java、C#等不支持多重类继承的语言，一次最多只能适配一个适配者类，<strong>不能同时适配多个适配者</strong>；</li>
<li><strong>适配者类不能为最终类</strong>，如在Java中不能为final类，C#中不能为sealed类；</li>
<li>在Java、C#等语言中，<strong>类适配器模式中的目标抽象类只能为接口，不能为类</strong>，其使用有一定的局限性。</li>
</ul>
<p><strong>对象适配器模式</strong>的缺点如下：</p>
<ul>
<li>与类适配器模式相比，<strong>要在适配器中置换适配者类的某些方法比较麻烦</strong>。如果一定要置换掉适配者类的一个或多个方法，可以先做一个适配者类的子类，将适配者类的方法置换掉，然后再把适配者类的子类当做真正的适配者进行适配，实现过程较为复杂。</li>
</ul>
<p><strong> 3. 适用场景</strong><br>在以下情况下可以考虑使用适配器模式：</p>
<ul>
<li>系统需要使用一些现有的类，而这些类的接口（如方法名）不符合系统的需要，甚至没有这些类的源代码。</li>
<li>想创建一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作。</li>
<li>（对对象的适配器模式而言）在设计里，需要改变多个已有的子类的接口，如果使用类的适配器模式，就要针对每一个子类做一个适配器类，而这不太实际。</li>
</ul>
<h1 id="整理的适配器模式思维导图"><a href="#整理的适配器模式思维导图" class="headerlink" title="整理的适配器模式思维导图"></a>整理的适配器模式思维导图</h1><p>用思维导图画了份总结，懒得看文章的也可以直接看图片，另外需要源文件的童鞋可以关注我个人主页上的公众号，回复<strong>适配器模式</strong>即可获取源文件网盘地址。<br><img src="http://7xqch5.com1.z0.glb.clouddn.com/adpater.png" alt=""></p>
<hr>
<p>博主弄了个java学习资源的公众号，学习资源超级多，视频，电子书，最新开发工具一个都不能少，已全部分享到百度云盘，求资源共享，打造一个学习方便，工作方便的java公众号，开源开源，有需求的可以关注~撒花<br>  <img src="http://7xqch5.com1.z0.glb.clouddn.com/javaLearn.PNG" alt=""></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/设计模式/">设计模式</a>
    </div>


      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-javajh5hashset" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/04/16/javajh5hashset/" class="article-date">
      <time datetime="2016-04-16T09:39:33.000Z" itemprop="datePublished">2016-04-16</time>
</a>

 
    <a href="/2016/04/16/javajh5hashset/#comments" title="查看评论">
        <i class="fa fa-comments-o" aria-hidden="true"></i>
        <span class="count-comment"></span>
        
            <span class="ds-thread-count"  data-thread-key="2016/04/16/javajh5hashset/" ></span>
        
        
    </a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/16/javajh5hashset/">Java集合干货系列-（五）HashSet源码解析</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>今天来介绍下HashSet。前面，我们已经系统的对List和Map进行了学习。接下来，我们开始可以学习Set。相信经过Map的了解之后，学习Set会容易很多。毕竟，Set的实现类都是基于Map来实现的(HashSet是通过HashMap实现的)。<br>构造图如下:<br>蓝色线条：继承<br>绿色线条：接口实现<br><img src="http://7xqch5.com1.z0.glb.clouddn.com/jh5_1.png" alt=""></p>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>对于HashSet而言，它是基于HashMap来实现的，底层采用HashMap来保存元素。所以如果对HashMap比较熟悉，那么HashSet是so  easy!!</p>
<h2 id="HashSet简介"><a href="#HashSet简介" class="headerlink" title="HashSet简介"></a>HashSet简介</h2><h3 id="HashSet定义"><a href="#HashSet定义" class="headerlink" title="HashSet定义"></a>HashSet定义</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashSet</span>&lt;<span class="title">E</span>&gt;</span><br><span class="line">     <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">E</span>&gt;</span><br><span class="line">     <span class="keyword">implements</span> <span class="title">Set</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure>
<p>HashSet 是一个<strong>没有重复元素的集合</strong>。<br>它是由HashMap实现的，<strong>不保证元素的顺序</strong>，而且<strong>HashSet允许使用 null 元素</strong>。<br>HashSet是<strong>非同步的</strong>。如果多个线程同时访问一个哈希 set，而其中至少一个线程修改了该 set，那么它必须 保持外部同步。这通常是通过对自然封装该 set 的对象执行同步操作来完成的。如果不存在这样的对象，则应该使用 Collections.synchronizedSet 方法来“包装” set。最好在创建时完成这一操作，以防止对该 set 进行意外的不同步访问：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set s = Collections.synchronizedSet(<span class="keyword">new</span> HashSet(...));</span><br></pre></td></tr></table></figure></p>
<p>HashSet通过iterator()返回的<strong>迭代器是fail-fast的。</strong></p>
<h3 id="HashSet属性"><a href="#HashSet属性" class="headerlink" title="HashSet属性"></a>HashSet属性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 底层使用HashMap来保存HashSet的元素</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> HashMap&lt;E,Object&gt; map;</span><br><span class="line">    <span class="comment">// Dummy value to associate with an Object in the backing Map</span></span><br><span class="line">    <span class="comment">// 由于Set只使用到了HashMap的key，所以此处定义一个静态的常量Object类，来充当HashMap的value</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object PRESENT = <span class="keyword">new</span> Object();</span><br></pre></td></tr></table></figure>
<p>看到这里就明白了，和我们前面说的一样，HashSet是用HashMap来保存数据，而主要使用到的就是HashMap的key。</p>
<p>看到<strong>private</strong> <strong>static</strong> <strong>final</strong> Object <em>PRESENT</em> = <strong>new</strong> Object();不知道你有没有一点疑问呢。这里使用一个静态的常量Object类来充当HashMap的value，既然这里map的value是没有意义的，为什么不直接使用null值来充当value呢？比如写成这样子<strong>private</strong> <strong>final</strong> Object <em>PRESENT</em> = <strong>null</strong>;我们都知道的是，Java首先将变量PRESENT分配在栈空间，而将new出来的Object分配到堆空间，这里的new Object()是占用堆内存的（一个空的Object对象占用8byte），而null值我们知道，是不会在堆空间分配内存的。那么想一想这里为什么不使用null值。想到什么吗，看一个异常类<strong>java.lang.NullPointerException</strong>， 噢买尬，这绝对是Java程序员的一个噩梦，这是所有Java程序猿都会遇到的一个异常，你看到这个异常你以为很好解决，但是有些时候也不是那么容易解决，Java号称没有指针，但是处处碰到NullPointerException。所以啊，为了从根源上避免NullPointerException的出现，浪费8个byte又怎么样，在下面的代码中我再也不会写这样的代码啦if (xxx == null) { … } else {….}，好爽。</p>
<h3 id="HashSet构造函数"><a href="#HashSet构造函数" class="headerlink" title="HashSet构造函数"></a>HashSet构造函数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">     * 使用HashMap的默认容量大小16和默认加载因子0.75初始化map，构造一个HashSet</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        map = <span class="keyword">new</span> HashMap&lt;E,Object&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 构造一个指定Collection参数的HashSet，这里不仅仅是Set，只要实现Collection接口的容器都可以</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        map = <span class="keyword">new</span> HashMap&lt;E,Object&gt;(Math. max((<span class="keyword">int</span>) (c.size()/.<span class="number">75f</span>) + <span class="number">1</span>, <span class="number">16</span>));</span><br><span class="line">       <span class="comment">// 使用Collection实现的Iterator迭代器，将集合c的元素一个个加入HashSet中</span></span><br><span class="line">       addAll(c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 使用指定的初始容量大小和加载因子初始化map，构造一个HashSet</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">( <span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">        map = <span class="keyword">new</span> HashMap&lt;E,Object&gt;(initialCapacity, loadFactor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 使用指定的初始容量大小和默认的加载因子0.75初始化map，构造一个HashSet</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">( <span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">        map = <span class="keyword">new</span> HashMap&lt;E,Object&gt;(initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 不对外公开的一个构造方法（默认default修饰），底层构造的是LinkedHashMap，dummy只是一个标示参数，无具体意义</span><br><span class="line">     */</span></span><br><span class="line">    HashSet( <span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor, <span class="keyword">boolean</span> dummy) &#123;</span><br><span class="line">        map = <span class="keyword">new</span> LinkedHashMap&lt;E,Object&gt;(initialCapacity, loadFactor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从构造方法可以很轻松的看出，HashSet的底层是一个HashMap，理解了HashMap后，这里没什么可说的。只有最后一个构造方法有写区别，这里构造的是LinkedHashMap，该方法不对外公开，实际上是提供给LinkedHashSet使用的，而第三个参数dummy是无意义的，只是为了区分其他构造方法。</p>
<h3 id="API方法摘要"><a href="#API方法摘要" class="headerlink" title="API方法摘要"></a>API方法摘要</h3><p><img src="http://7xqch5.com1.z0.glb.clouddn.com/jh5_2.png" alt=""></p>
<h2 id="HashSet源码解析-基于JDK1-6-0-45"><a href="#HashSet源码解析-基于JDK1-6-0-45" class="headerlink" title="HashSet源码解析(基于JDK1.6.0_45)"></a>HashSet源码解析(基于JDK1.6.0_45)</h2><h3 id="增加和删除"><a href="#增加和删除" class="headerlink" title="增加和删除"></a>增加和删除</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">     * 利用HashMap的put方法实现add方法</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> map .put(e, PRESENT)== <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 利用HashMap的remove方法实现remove方法</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> map .remove(o)==PRESENT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 添加一个集合到HashSet中，该方法在AbstractCollection中</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> modified = <span class="keyword">false</span>;</span><br><span class="line">       <span class="comment">// 取得集合c迭代器Iterator</span></span><br><span class="line">       Iterator&lt;? extends E&gt; e = c.iterator();</span><br><span class="line">       <span class="comment">// 遍历迭代器</span></span><br><span class="line">        <span class="keyword">while</span> (e.hasNext()) &#123;</span><br><span class="line">           <span class="comment">// 将集合c的每个元素加入到HashSet中</span></span><br><span class="line">           <span class="keyword">if</span> (add(e.next()))</span><br><span class="line">              modified = <span class="keyword">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">        <span class="keyword">return</span> modified;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 删除指定集合c中的所有元素，该方法在AbstractSet中</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">removeAll</span><span class="params">(Collection&lt;?&gt; c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> modified = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断当前HashSet元素个数和指定集合c的元素个数，目的是减少遍历次数</span></span><br><span class="line">        <span class="keyword">if</span> (size() &gt; c.size()) &#123;</span><br><span class="line">            <span class="comment">// 如果当前HashSet元素多，则遍历集合c，将集合c中的元素一个个删除</span></span><br><span class="line">            <span class="keyword">for</span> (Iterator&lt;?&gt; i = c.iterator(); i.hasNext(); )</span><br><span class="line">                modified |= remove(i.next());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果集合c元素多，则遍历当前HashSet，将集合c中包含的元素一个个删除</span></span><br><span class="line">            <span class="keyword">for</span> (Iterator&lt;?&gt; i = iterator(); i.hasNext(); ) &#123;</span><br><span class="line">                <span class="keyword">if</span> (c.contains(i.next())) &#123;</span><br><span class="line">                    i.remove();</span><br><span class="line">                    modified = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> modified;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="是否包含"><a href="#是否包含" class="headerlink" title="是否包含"></a>是否包含</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">     * 利用HashMap的containsKey方法实现contains方法</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> map .containsKey(o);</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 检查是否包含指定集合中所有元素，该方法在AbstractCollection中</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsAll</span><span class="params">(Collection&lt;?&gt; c)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 取得集合c的迭代器Iterator</span></span><br><span class="line">       Iterator&lt;?&gt; e = c.iterator();</span><br><span class="line">       <span class="comment">// 遍历迭代器，只要集合c中有一个元素不属于当前HashSet，则返回false</span></span><br><span class="line">        <span class="keyword">while</span> (e.hasNext())</span><br><span class="line">           <span class="keyword">if</span> (!contains(e.next()))</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><strong>由于HashMap基于hash表实现，hash表实现的容器最重要的一点就是可以快速存取，那么HashSet对于contains方法，利用HashMap的containsKey方法，效率是非常之快的。在我看来，这个方法也是HashSet最核心的卖点方法之一。</strong></strong></p>
<h3 id="容量检查"><a href="#容量检查" class="headerlink" title="容量检查"></a>容量检查</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">     * Returns the number of elements in this set (its cardinality).</span><br><span class="line">     *</span><br><span class="line">     * <span class="doctag">@return</span> the number of elements in this set (its cardinality)</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> map .size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Returns &lt;tt&gt;true&lt;/tt&gt; if this set contains no elements.</span><br><span class="line">     *</span><br><span class="line">     * <span class="doctag">@return</span> &lt;tt&gt; true&lt;/tt&gt; if this set contains no elements</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> map .isEmpty();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="HashSet遍历方式"><a href="#HashSet遍历方式" class="headerlink" title="HashSet遍历方式"></a>HashSet遍历方式</h3><h4 id="通过Iterator遍历HashSet"><a href="#通过Iterator遍历HashSet" class="headerlink" title="通过Iterator遍历HashSet"></a>通过Iterator遍历HashSet</h4><p>第一步：<strong>根据iterator()获取HashSet的迭代器。</strong><br>第二步：<strong>遍历迭代器获取各个元素</strong>。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设set是HashSet对象</span></span><br><span class="line"><span class="keyword">for</span>(Iterator iterator = set.iterator();</span><br><span class="line">       iterator.hasNext(); ) &#123; </span><br><span class="line">    iterator.next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="通过for-each遍历HashSet"><a href="#通过for-each遍历HashSet" class="headerlink" title="通过for-each遍历HashSet"></a>通过for-each遍历HashSet</h4><p>第一步：<strong>根据toArray()获取HashSet的元素集合对应的数组。</strong><br>第二步：<strong>遍历数组，获取各个元素。</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设set是HashSet对象，并且set中元素是String类型</span></span><br><span class="line">String[] arr = (String[])set.toArray(<span class="keyword">new</span> String[<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">for</span> (String str:arr)</span><br><span class="line">    System.out.printf(<span class="string">"for each : %s\n"</span>, str);</span><br></pre></td></tr></table></figure></p>
<h3 id="HashSet示例"><a href="#HashSet示例" class="headerlink" title="HashSet示例"></a>HashSet示例</h3><p>下面我们通过实例学习如何使用HashSet<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span><br><span class="line"> * @desc HashSet常用API的使用。</span><br><span class="line"> *</span><br><span class="line"> * @author skywang</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashSetTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// HashSet常用API</span></span><br><span class="line">        testHashSetAPIs() ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span><br><span class="line">     * HashSet除了iterator()和add()之外的其它常用API</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testHashSetAPIs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 新建HashSet</span></span><br><span class="line">        HashSet set = <span class="keyword">new</span> HashSet();</span><br><span class="line">        <span class="comment">// 将元素添加到Set中</span></span><br><span class="line">        set.add(<span class="string">"a"</span>);</span><br><span class="line">        set.add(<span class="string">"b"</span>);</span><br><span class="line">        set.add(<span class="string">"c"</span>);</span><br><span class="line">        set.add(<span class="string">"d"</span>);</span><br><span class="line">        set.add(<span class="string">"e"</span>);</span><br><span class="line">        <span class="comment">// 打印HashSet的实际大小</span></span><br><span class="line">        System.out.printf(<span class="string">"size : %d\n"</span>, set.size());</span><br><span class="line">        <span class="comment">// 判断HashSet是否包含某个值</span></span><br><span class="line">        System.out.printf(<span class="string">"HashSet contains a :%s\n"</span>, set.contains(<span class="string">"a"</span>));</span><br><span class="line">        System.out.printf(<span class="string">"HashSet contains g :%s\n"</span>, set.contains(<span class="string">"g"</span>));</span><br><span class="line">        <span class="comment">// 删除HashSet中的“e”</span></span><br><span class="line">        set.remove(<span class="string">"e"</span>);</span><br><span class="line">        <span class="comment">// 将Set转换为数组</span></span><br><span class="line">        String[] arr = (String[])set.toArray(<span class="keyword">new</span> String[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span> (String str:arr)</span><br><span class="line">            System.out.printf(<span class="string">"for each : %s\n"</span>, str);</span><br><span class="line">        <span class="comment">// 新建一个包含b、c、f的HashSet</span></span><br><span class="line">        HashSet otherset = <span class="keyword">new</span> HashSet();</span><br><span class="line">        otherset.add(<span class="string">"b"</span>);</span><br><span class="line">        otherset.add(<span class="string">"c"</span>);</span><br><span class="line">        otherset.add(<span class="string">"f"</span>);</span><br><span class="line">        <span class="comment">// 克隆一个removeset，内容和set一模一样</span></span><br><span class="line">        HashSet removeset = (HashSet)set.clone();</span><br><span class="line">        <span class="comment">// 删除“removeset中，属于otherSet的元素”</span></span><br><span class="line">        removeset.removeAll(otherset);</span><br><span class="line">        <span class="comment">// 打印removeset</span></span><br><span class="line">        System.out.printf(<span class="string">"removeset : %s\n"</span>, removeset);</span><br><span class="line">        <span class="comment">// 克隆一个retainset，内容和set一模一样</span></span><br><span class="line">        HashSet retainset = (HashSet)set.clone();</span><br><span class="line">        <span class="comment">// 保留“retainset中，属于otherSet的元素”</span></span><br><span class="line">        retainset.retainAll(otherset);</span><br><span class="line">        <span class="comment">// 打印retainset</span></span><br><span class="line">        System.out.printf(<span class="string">"retainset : %s\n"</span>, retainset);</span><br><span class="line">        <span class="comment">// 遍历HashSet</span></span><br><span class="line">        <span class="keyword">for</span>(Iterator iterator = set.iterator();iterator.hasNext();) </span><br><span class="line">            System.out.printf(<span class="string">"iterator : %s\n"</span>, iterator.next());</span><br><span class="line">        <span class="comment">// 清空HashSet</span></span><br><span class="line">        set.clear();</span><br><span class="line">        <span class="comment">// 输出HashSet是否为空</span></span><br><span class="line">        System.out.printf(<span class="string">"%s\n"</span>, set.isEmpty()?<span class="string">"set is empty"</span>:<span class="string">"set is not empty"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">size : <span class="number">5</span></span><br><span class="line">HashSet contains a :<span class="keyword">true</span></span><br><span class="line">HashSet contains g :<span class="keyword">false</span></span><br><span class="line"><span class="keyword">for</span> each : d</span><br><span class="line"><span class="keyword">for</span> each : b</span><br><span class="line"><span class="keyword">for</span> each : c</span><br><span class="line"><span class="keyword">for</span> each : a</span><br><span class="line">removeset : [d, a]</span><br><span class="line">retainset : [b, c]</span><br><span class="line">iterator : d</span><br><span class="line">iterator : b</span><br><span class="line">iterator : c</span><br><span class="line">iterator : a</span><br><span class="line">set is empty</span><br></pre></td></tr></table></figure></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="HashSet和HashMap、Hashtable的区别"><a href="#HashSet和HashMap、Hashtable的区别" class="headerlink" title="HashSet和HashMap、Hashtable的区别"></a>HashSet和HashMap、Hashtable的区别</h2><p><img src="http://7xqch5.com1.z0.glb.clouddn.com/jh5_3.png" alt=""></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>该文为本人学习的笔记，方便以后自己跳槽前复习。参考网上各大帖子，取其精华整合自己的理解而成。集合框架源码面试经常会问，所以解读源码十分必要,希望对你有用。<br><a href="http://www.cnblogs.com/chenssy/p/3621851.html" target="_blank" rel="external">java提高篇（二四）—–HashSet</a><br><a href="http://www.cnblogs.com/skywang12345/p/3311252.html" target="_blank" rel="external">Java 集合系列16之 HashSet详细介绍(源码解析)和使用示例</a><br><a href="http://www.cnblogs.com/tstd/p/5064032.html" target="_blank" rel="external">给jdk写注释系列之jdk1.6容器(6)-HashSet源码解析&amp;Map迭代器</a></p>
<h1 id="整理的集合框架思维导图"><a href="#整理的集合框架思维导图" class="headerlink" title="整理的集合框架思维导图"></a>整理的集合框架思维导图</h1><p>个人整理的Java集合框架思维导图，动态维护。导出的图片无法查看备注的一些信息，所以需要源文件的童鞋可以关注我个人主页上的公众号，回复<strong>Java集合框架</strong>即可获取源文件。<br><img src="http://7xqch5.com1.z0.glb.clouddn.com/jhswdt.png" alt=""></p>
<hr>
<p>博主弄了个java学习资源的公众号，学习资源超级多，视频，电子书，最新开发工具一个都不能少，已全部分享到百度云盘，求资源共享，打造一个学习方便，工作方便的java公众号，开源开源，有需求的可以关注~撒花<br>  <img src="http://7xqch5.com1.z0.glb.clouddn.com/javaLearn.PNG" alt=""></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Java集合干货系列/">Java集合干货系列</a>
    </div>


      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-javajh4treemap" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/04/16/javajh4treemap/" class="article-date">
      <time datetime="2016-04-16T09:39:18.000Z" itemprop="datePublished">2016-04-16</time>
</a>

 
    <a href="/2016/04/16/javajh4treemap/#comments" title="查看评论">
        <i class="fa fa-comments-o" aria-hidden="true"></i>
        <span class="count-comment"></span>
        
            <span class="ds-thread-count"  data-thread-key="2016/04/16/javajh4treemap/" ></span>
        
        
    </a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/16/javajh4treemap/">Java集合干货系列-（四）TreeMap源码解析</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>今天来介绍下TreeMap,TreeMap是基于红黑树结构实现的一种Map，要分析TreeMap的实现首先就要对红黑树有所了解。<br>构造图如下:<br>蓝色线条：继承<br>绿色线条：接口实现<br><img src="http://7xqch5.com1.z0.glb.clouddn.com/jh4_1.png" alt=""></p>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>TreeMap底层是基于<strong>红黑树（Red-Black tree）实现</strong>，所以在学习TreeMap之前我们先来了解下红黑树。<br>红黑树又称红-黑二叉树，它首先是一颗二叉树，它具体二叉树所有的特性。同时红黑树更是一颗自平衡的排序二叉树。<br>我们知道一颗基本的二叉树他们都需要满足一个基本性质–即树中的任何节点的值大于它的左子节点，且小于它的右子节点。按照这个基本性质使得树的检索效率大大提高。我们知道在生成二叉树的过程是非常容易失衡的，最坏的情况就是一边倒（只有右/左子树），这样势必会导致二叉树的检索效率大大降低（O(n)），所以为了维持二叉树的平衡，大牛们提出了各种实现的算法，如：<a href="http://baike.baidu.com/view/414610.htm" target="_blank" rel="external">AVL</a>，<a href="http://baike.baidu.com/view/2957252.htm" target="_blank" rel="external">SBT</a>，<a href="http://baike.baidu.com/view/1118088.htm" target="_blank" rel="external">伸展树</a>，<a href="http://baike.baidu.com/view/956602.htm" target="_blank" rel="external">TREAP</a> ，<a href="http://baike.baidu.com/view/133754.htm?fr=aladdin#1_1" target="_blank" rel="external">红黑树</a>等等。</p>
<p>平衡二叉树必须具备如下特性：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。也就是说该二叉树的任何一个等等子节点，其左右子树的高度都相近。<br><img src="http://7xqch5.com1.z0.glb.clouddn.com/jh4_2.png" alt=""><br>红黑树顾名思义就是节点是红色或者黑色的平衡二叉树，它通过颜色的约束来维持着二叉树的平衡。对于一棵有效的红黑树二叉树而言我们必须增加如下规则：</p>
<ol>
<li>每个节点都只能是红色或者黑色</li>
<li>根节点是黑色</li>
<li>每个叶节点（NIL节点，空节点）是黑色的。</li>
<li>如果一个结点是红的，则它两个子节点都是黑的。也就是说在一条路径上不能出现相邻的两个红色结点。</li>
<li>从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。</li>
</ol>
<p>红黑树示意图如下：<br><img src="http://7xqch5.com1.z0.glb.clouddn.com/jh4_3.png" alt=""></p>
<p>上面的规则前4条都好理解，第5条规则到底是什么情况，下面简单解释下，比如图中红8到1左边的叶子节点的路径包含两个黑色节点，到6下面的叶子节点的路径也包含两个黑色节点。</p>
<p>但是在在添加或删除节点后，红黑树就发生了变化，可能不再满足上面的5个特性，为了保持红黑树的以上特性，就有了三个动作：左旋、右旋、着色。</p>
<p>下面来看下什么是红黑树的左旋和右旋：<br><img src="http://7xqch5.com1.z0.glb.clouddn.com/jh4_4.jpg" alt=""></p>
<p><strong>对x进行左旋，意味着”将x变成一个左节点”</strong>。<br><img src="http://7xqch5.com1.z0.glb.clouddn.com/jh4_5.jpg" alt=""></p>
<p><strong>对y进行右旋，意味着”将y变成一个右节点”。</strong><br>  如果还是没看明白，下面找了两张左旋和右旋的动态图<br>  <img src="http://7xqch5.com1.z0.glb.clouddn.com/jh4_6.gif" alt=""><br>  <img src="http://7xqch5.com1.z0.glb.clouddn.com/jh4_7.gif" alt=""><br> ok，对二叉树、红黑树的概念有所了解后，我们来看下红黑树的两个主要逻辑添加和删除，看看TreeMap是怎么实现的。</p>
<h2 id="TreeMap简介"><a href="#TreeMap简介" class="headerlink" title="TreeMap简介"></a>TreeMap简介</h2><h3 id="TreeMap定义"><a href="#TreeMap定义" class="headerlink" title="TreeMap定义"></a>TreeMap定义</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span><br><span class="line">    <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title">NavigableMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure>
<p>TreeMap 是一个<strong>有序的key-value集合</strong>，它是通过<code>红黑树</code>实现的。<br>TreeMap <strong>继承于AbstractMap</strong>，所以它是一个Map，即一个key-value集合。<br>TreeMap 实现了NavigableMap接口，意味着它<strong>支持一系列的导航方法。</strong>比如返回有序的key集合。<br>TreeMap 实现了Cloneable接口，意味着<strong>它能被克隆</strong>。<br>TreeMap 实现了java.io.Serializable接口，意味着<strong>它支持序列化</strong>。</p>
<p>TreeMap基于<strong>红黑树（Red-Black tree）实现</strong>。该映射根据<strong>其键的自然顺序进行排序</strong>，或者根据<strong>创建映射时提供的 Comparator 进行排序</strong>，具体取决于使用的构造方法。<br>TreeMap的基本操作 containsKey、get、put 和 remove 的时间复杂度是 log(n) 。<br>另外，TreeMap是<strong>非同步</strong>的。 它的iterator 方法返回的<strong>迭代器是fail-fast</strong>的。</p>
<h3 id="TreeMap属性"><a href="#TreeMap属性" class="headerlink" title="TreeMap属性"></a>TreeMap属性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 比较器</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Comparator&lt;? <span class="keyword">super</span> K&gt; comparator;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 红黑树根节点</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Entry&lt;K,V&gt; root = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 集合元素数量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// "fail-fast"集合修改记录</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> modCount = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>TreeMap的本质是R-B Tree(红黑树)，它包含几个重要的成员变量： root, size, comparator。</p>
<ul>
<li>root 是红黑数的根节点。它是Entry类型，Entry是红黑数的节点，它包含了红黑数的6个基本组成成分：key(键)、value(值)、left(左孩子)、right(右孩子)、parent(父节点)、color(颜色)。Entry节点根据key进行排序，Entry节点包含的内容为value。 </li>
<li>红黑数排序时，根据Entry中的key进行排序；Entry中的key比较大小是根据比较器comparator来进行判断的。</li>
<li>size是红黑数中节点的个数。</li>
</ul>
<p>Entry是树的节点类，我们来看一下Entry的定义：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">       K key;</span><br><span class="line">        V value;</span><br><span class="line">        <span class="comment">// 左孩子节点</span></span><br><span class="line">        Entry&lt;K,V&gt; left = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 右孩子节点</span></span><br><span class="line">        Entry&lt;K,V&gt; right = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 父节点</span></span><br><span class="line">        Entry&lt;K,V&gt; parent;</span><br><span class="line">        <span class="comment">// 红黑树用来表示节点颜色的属性，默认为黑色</span></span><br><span class="line">        <span class="keyword">boolean</span> color = BLACK;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span><br><span class="line">         * 用key，value和父节点构造一个Entry，默认为黑色</span><br><span class="line">         */</span></span><br><span class="line">        Entry(K key, V value, Entry&lt;K,V&gt; parent) &#123;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">            <span class="keyword">this</span>.parent = parent;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> K <span class="title">getKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> key ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> V <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> value ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> V <span class="title">setValue</span><span class="params">(V value)</span> </span>&#123;</span><br><span class="line">            V oldValue = <span class="keyword">this</span>.value ;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Map.Entry))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> valEquals( key,e.getKey()) &amp;&amp; valEquals( value,e.getValue());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> keyHash = (key ==<span class="keyword">null</span> ? <span class="number">0</span> : key.hashCode());</span><br><span class="line">            <span class="keyword">int</span> valueHash = (value ==<span class="keyword">null</span> ? <span class="number">0</span> : value.hashCode());</span><br><span class="line">            <span class="keyword">return</span> keyHash ^ valueHash;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> key + <span class="string">"="</span> + value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>Entry类理解起来比较简单（因为我们前面看过很多的Entry类了），主要是定义了树的孩子和父亲节点引用，和红黑颜色属性，并对equals和hashCode进行重写，以利于比较是否相等。</p>
<h3 id="HashMap构造函数"><a href="#HashMap构造函数" class="headerlink" title="HashMap构造函数"></a>HashMap构造函数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">     * 默认构造方法，comparator为空，代表使用key的自然顺序来维持TreeMap的顺序，这里要求key必须实现Comparable接口</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TreeMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        comparator = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 用指定的比较器构造一个TreeMap</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TreeMap</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> K&gt; comparator)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.comparator = comparator;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 构造一个指定map的TreeMap，同样比较器comparator为空，使用key的自然顺序排序</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TreeMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">        comparator = <span class="keyword">null</span>;</span><br><span class="line">        putAll(m);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 构造一个指定SortedMap的TreeMap，根据SortedMap的比较器来来维持TreeMap的顺序</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TreeMap</span><span class="params">(SortedMap&lt;K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">        comparator = m.comparator();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            buildFromSorted(m.size(), m.entrySet().iterator(), <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (java.io.IOException cannotHappen) &#123;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException cannotHappen) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>从构造方法中可以看出，要创建一个红黑树实现的TreeMap必须要有一个用于比较大小的比较器，因为只有能够比较大小才能实现红黑树的左孩子&lt;树根&lt;右孩子的特点。</p>
<h3 id="API方法摘要"><a href="#API方法摘要" class="headerlink" title="API方法摘要"></a>API方法摘要</h3><p><img src="http://7xqch5.com1.z0.glb.clouddn.com/jh4_8.png" alt=""><br><img src="http://7xqch5.com1.z0.glb.clouddn.com/jh4_9.png" alt=""></p>
<h2 id="TreeMap源码解析-基于JDK1-6-0-45"><a href="#TreeMap源码解析-基于JDK1-6-0-45" class="headerlink" title="TreeMap源码解析(基于JDK1.6.0_45)"></a>TreeMap源码解析(基于JDK1.6.0_45)</h2><h3 id="红黑树的添加原理及TreeMap的put实现"><a href="#红黑树的添加原理及TreeMap的put实现" class="headerlink" title="红黑树的添加原理及TreeMap的put实现"></a>红黑树的添加原理及TreeMap的put实现</h3><p>将一个节点添加到红黑树中，通常需要下面几个步骤：</p>
<ol>
<li>将红黑树当成一颗二叉查找树，将节点插入.<br>这一步比较简单，就上开始我们自己写的二叉查找树的操作一样，至于为什么可以这样插入，是因为红黑树本身就是一个二叉查找树。</li>
<li>将新插入的节点设置为红色<br>有没有疑问，为什么新插入的节点一定要是红色的，因为新插入节点为红色，不会违背红黑规则第（5）条，少违背一条就少处理一种情况。</li>
<li>通过旋转和着色，使它恢复平衡，重新变成一颗符合规则的红黑树。<br>要想知道怎么样进行左旋和右旋，首先就要知道为什么要进行左旋和右旋。</li>
</ol>
<p>我们来对比下红黑树的规则和新插入节点后的情况，看下新插入节点会违背哪些规则。</p>
<blockquote>
<p>（1）节点是红色或黑色。<br>这一点肯定是不会违背的了。<br>（2）根节点是黑色。<br>这一点也不会违背了，如果是根节点，只需将根节点插入就好了，因为默认是黑色。<br>（3）每个叶节点（NIL节点，空节点）是黑色的。<br>这一点也不会违背的，我们插入的是非空的节点，不会影响空节点。<br>（4）每个红色节点的两个子节点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点)<br><strong>这一点是有可能违背的，我们将新插入的节点都设置成红色，如果其父节点也是红色的话，那就产生冲突了</strong>。<br>（5）从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。<br>这一点也不会违背，因为我们将新插入的节点都设置成红色。</p>
</blockquote>
<p>了解了红黑树左旋和右旋操作，以及新插入节点主要是可能会违背红黑树的规则（4）后，我们来分析下，添加新节点的过程有哪几种情况：</p>
<p>（1）新插入节点为根节点。这种情况直接将新插入节点设置为根节点即可，无需进行后续的旋转和着色处理。</p>
<p>（2）新插入节点的父节点是黑色。这种情况直接将新节点插入即可，不会违背规则（4）。</p>
<p>（3）新插入节点的父节点是红色。这种情况会违背规则（4），而这种情况又分为了以下几种，下面进行图解：<br>①新插入节点N的父节点P和叔叔节点U都是红色。方法是：<strong>将祖父节点G设置为红色，父节点P和叔叔节点U设置为黑色</strong>，这时候就看似平衡了。<strong>但是</strong>，如果祖父节点G的父节点也是红色，这时候又违背规则（4）了，怎么办，方法是：将GPUN这一组看成一个新的节点，按照前面的方案递归；<strong>又但是</strong>根节点为红就违反规则（2）了，怎么办，方法是直接将根节点设置为黑色（两个连续黑色是没问题的）。<br><img src="http://7xqch5.com1.z0.glb.clouddn.com/jh4_10.png" alt=""></p>
<p>②新插入节点N的父节点P是红色，叔叔节点U是黑色或者缺少，且新节点N是P的右孩子。方法是：<strong>左旋父节点P</strong>。左旋后N和P角色互换，但是P和N还是连续的两个红色节点，还没有平衡，怎么办，看第三种情况。<br><img src="http://7xqch5.com1.z0.glb.clouddn.com/jh4_11.png" alt=""></p>
<p>③新插入节点N的父节点P是红色，叔叔节点U是黑色或者缺少，且新节点N是P的左孩子。方法是：<strong>右旋祖父节点G，然后将P设置为黑色，G设置为红色，达到平衡</strong>。此时父节点P是黑色，所有不用担心P的父节点是红色。<br><img src="http://7xqch5.com1.z0.glb.clouddn.com/jh4_12.png" alt=""><br><strong>当然上面说的三种情况都是基于一个前提：新插入节点N的父节点P是祖父节点G的左孩子</strong>，如果P是G的右孩子又是什么情况呢？其实情况和上面是相似的，只需要调整左旋还是右旋，这里就不细讲了。</p>
<p>上面分析了这么多，到底TreeMap是怎么实现的呢，我们来看下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 根节点</span></span><br><span class="line">        Entry&lt;K,V&gt; t = root;</span><br><span class="line">        <span class="comment">// 如果根节点为空，则直接创建一个根节点，返回</span></span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="comment">// TBD:</span></span><br><span class="line">           <span class="comment">// 5045147: (coll) Adding null to an empty TreeSet should</span></span><br><span class="line">           <span class="comment">// throw NullPointerException</span></span><br><span class="line">           <span class="comment">//</span></span><br><span class="line">           <span class="comment">// compare(key, key); // type check</span></span><br><span class="line">            root = <span class="keyword">new</span> Entry&lt;K,V&gt;(key, value, <span class="keyword">null</span>);</span><br><span class="line">            size = <span class="number">1</span>;</span><br><span class="line">            modCount++;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 记录比较结果</span></span><br><span class="line">        <span class="keyword">int</span> cmp;</span><br><span class="line">        Entry&lt;K,V&gt; parent;</span><br><span class="line">        <span class="comment">// split comparator and comparable paths</span></span><br><span class="line">        <span class="comment">// 当前使用的比较器</span></span><br><span class="line">        Comparator&lt;? <span class="keyword">super</span> K&gt; cpr = comparator ;</span><br><span class="line">        <span class="comment">// 如果比较器不为空，就是用指定的比较器来维护TreeMap的元素顺序</span></span><br><span class="line">        <span class="keyword">if</span> (cpr != <span class="keyword">null</span>) &#123;</span><br><span class="line">             <span class="comment">// do while循环，查找key要插入的位置（也就是新节点的父节点是谁）</span></span><br><span class="line">            do &#123;</span><br><span class="line">                <span class="comment">// 记录上次循环的节点t</span></span><br><span class="line">                parent = t;</span><br><span class="line">                <span class="comment">// 比较当前节点的key和新插入的key的大小</span></span><br><span class="line">                cmp = cpr.compare(key, t. key);</span><br><span class="line">                 <span class="comment">// 新插入的key小的话，则以当前节点的左孩子节点为新的比较节点</span></span><br><span class="line">                <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">                    t = t. left;</span><br><span class="line">                <span class="comment">// 新插入的key大的话，则以当前节点的右孩子节点为新的比较节点</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">                    t = t. right;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">              <span class="comment">// 如果当前节点的key和新插入的key想的的话，则覆盖map的value，返回</span></span><br><span class="line">                    <span class="keyword">return</span> t.setValue(value);</span><br><span class="line">            <span class="comment">// 只有当t为null，也就是没有要比较节点的时候，代表已经找到新节点要插入的位置</span></span><br><span class="line">            &#125; <span class="keyword">while</span> (t != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果比较器为空，则使用key作为比较器进行比较</span></span><br><span class="line">            <span class="comment">// 这里要求key不能为空，并且必须实现Comparable接口</span></span><br><span class="line">            <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">            Comparable&lt;? <span class="keyword">super</span> K&gt; k = (Comparable&lt;? <span class="keyword">super</span> K&gt;) key;</span><br><span class="line">            <span class="comment">// 和上面一样，喜欢查找新节点要插入的位置</span></span><br><span class="line">            do &#123;</span><br><span class="line">                parent = t;</span><br><span class="line">                cmp = k.compareTo(t. key);</span><br><span class="line">                <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">                    t = t. left;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">                    t = t. right;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">return</span> t.setValue(value);</span><br><span class="line">            &#125; <span class="keyword">while</span> (t != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 找到新节点的父节点后，创建节点对象</span></span><br><span class="line">        Entry&lt;K,V&gt; e = <span class="keyword">new</span> Entry&lt;K,V&gt;(key, value, parent);</span><br><span class="line">        <span class="comment">// 如果新节点key的值小于父节点key的值，则插在父节点的左侧</span></span><br><span class="line">        <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">            parent. left = e;</span><br><span class="line">        <span class="comment">// 如果新节点key的值大于父节点key的值，则插在父节点的右侧</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            parent. right = e;</span><br><span class="line">        <span class="comment">// 插入新的节点后，为了保持红黑树平衡，对红黑树进行调整</span></span><br><span class="line">        fixAfterInsertion(e);</span><br><span class="line">        <span class="comment">// map元素个数+1</span></span><br><span class="line">        size++;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 新增节点后对红黑树的调整方法 */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fixAfterInsertion</span><span class="params">(Entry&lt;K,V&gt; x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 将新插入节点的颜色设置为红色</span></span><br><span class="line">        x. color = RED;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// while循环，保证新插入节点x不是根节点或者新插入节点x的父节点不是红色（这两种情况不需要调整）</span></span><br><span class="line">        <span class="keyword">while</span> (x != <span class="keyword">null</span> &amp;&amp; x != root &amp;&amp; x. parent.color == RED) &#123;</span><br><span class="line">            <span class="comment">// 如果新插入节点x的父节点是祖父节点的左孩子</span></span><br><span class="line">            <span class="keyword">if</span> (parentOf(x) == leftOf(parentOf (parentOf(x)))) &#123;</span><br><span class="line">                <span class="comment">// 取得新插入节点x的叔叔节点</span></span><br><span class="line">                Entry&lt;K,V&gt; y = rightOf(parentOf (parentOf(x)));</span><br><span class="line">                <span class="comment">// 如果新插入x的父节点是红色-------------------①</span></span><br><span class="line">                <span class="keyword">if</span> (colorOf(y) == RED) &#123;</span><br><span class="line">                    <span class="comment">// 将x的父节点设置为黑色</span></span><br><span class="line">                    setColor(parentOf (x), BLACK);</span><br><span class="line">                    <span class="comment">// 将x的叔叔节点设置为黑色</span></span><br><span class="line">                    setColor(y, BLACK);</span><br><span class="line">                    <span class="comment">// 将x的祖父节点设置为红色</span></span><br><span class="line">                    setColor(parentOf (parentOf(x)), RED);</span><br><span class="line">                    <span class="comment">// 将x指向祖父节点，如果x的祖父节点的父节点是红色，按照上面的步奏继续循环</span></span><br><span class="line">                    x = parentOf(parentOf (x));</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 如果新插入x的叔叔节点是黑色或缺少，且x的父节点是祖父节点的右孩子-------------------②</span></span><br><span class="line">                    <span class="keyword">if</span> (x == rightOf( parentOf(x))) &#123;</span><br><span class="line">                        <span class="comment">// 左旋父节点</span></span><br><span class="line">                        x = parentOf(x);</span><br><span class="line">                        rotateLeft(x);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 如果新插入x的叔叔节点是黑色或缺少，且x的父节点是祖父节点的左孩子-------------------③</span></span><br><span class="line">                    <span class="comment">// 将x的父节点设置为黑色</span></span><br><span class="line">                    setColor(parentOf (x), BLACK);</span><br><span class="line">                    <span class="comment">// 将x的祖父节点设置为红色</span></span><br><span class="line">                    setColor(parentOf (parentOf(x)), RED);</span><br><span class="line">                    <span class="comment">// 右旋x的祖父节点</span></span><br><span class="line">                    rotateRight( parentOf(parentOf (x)));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果新插入节点x的父节点是祖父节点的右孩子，下面的步奏和上面的相似，只不过左旋右旋的区分，不在细讲</span></span><br><span class="line">                Entry&lt;K,V&gt; y = leftOf(parentOf (parentOf(x)));</span><br><span class="line">                <span class="keyword">if</span> (colorOf(y) == RED) &#123;</span><br><span class="line">                    setColor(parentOf (x), BLACK);</span><br><span class="line">                    setColor(y, BLACK);</span><br><span class="line">                    setColor(parentOf (parentOf(x)), RED);</span><br><span class="line">                    x = parentOf(parentOf (x));</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (x == leftOf( parentOf(x))) &#123;</span><br><span class="line">                        x = parentOf(x);</span><br><span class="line">                        rotateRight(x);</span><br><span class="line">                    &#125;</span><br><span class="line">                    setColor(parentOf (x), BLACK);</span><br><span class="line">                    setColor(parentOf (parentOf(x)), RED);</span><br><span class="line">                    rotateLeft( parentOf(parentOf (x)));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最后将根节点设置为黑色，不管当前是不是红色，反正根节点必须是黑色</span></span><br><span class="line">        root.color = BLACK;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 对红黑树的节点(x)进行左旋转</span><br><span class="line">     *</span><br><span class="line">     * 左旋示意图(对节点x进行左旋)：</span><br><span class="line">     *      px                              px</span><br><span class="line">     *     /                               /</span><br><span class="line">     *    x                               y               </span><br><span class="line">     *   /  \      --(左旋)--           / \                </span><br><span class="line">     *  lx   y                          x  ry    </span><br><span class="line">     *     /   \                       /  \</span><br><span class="line">     *    ly   ry                     lx  ly </span><br><span class="line">     *</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rotateLeft</span><span class="params">(Entry&lt;K,V&gt; p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 取得要选择节点p的右孩子</span></span><br><span class="line">            Entry&lt;K,V&gt; r = p. right;</span><br><span class="line">            <span class="comment">// "p"和"r的左孩子"的相互指向...</span></span><br><span class="line">            <span class="comment">// 将"r的左孩子"设为"p的右孩子"</span></span><br><span class="line">            p. right = r.left ;</span><br><span class="line">            <span class="comment">// 如果r的左孩子非空，将"p"设为"r的左孩子的父亲"</span></span><br><span class="line">            <span class="keyword">if</span> (r.left != <span class="keyword">null</span>)</span><br><span class="line">                r. left.parent = p;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// "p的父亲"和"r"的相互指向...</span></span><br><span class="line">            <span class="comment">// 将"p的父亲"设为"y的父亲"</span></span><br><span class="line">            r. parent = p.parent ;</span><br><span class="line">            <span class="comment">// 如果"p的父亲"是空节点，则将r设为根节点</span></span><br><span class="line">            <span class="keyword">if</span> (p.parent == <span class="keyword">null</span>)</span><br><span class="line">                root = r;</span><br><span class="line">            <span class="comment">// 如果p是它父节点的左孩子，则将r设为"p的父节点的左孩子"</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p.parent. left == p)</span><br><span class="line">                p. parent.left = r;</span><br><span class="line">            <span class="keyword">else</span>             </span><br><span class="line">                <span class="comment">// 如果p是它父节点的左孩子，则将r设为"p的父节点的左孩子"</span></span><br><span class="line">                p. parent.right = r;</span><br><span class="line">            <span class="comment">// "p"和"r"的相互指向...</span></span><br><span class="line">            <span class="comment">// 将"p"设为"r的左孩子"</span></span><br><span class="line">            r. left = p;</span><br><span class="line">            <span class="comment">// 将"p的父节点"设为"r"</span></span><br><span class="line">            p. parent = r;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 对红黑树的节点进行右旋转</span><br><span class="line">     *</span><br><span class="line">     * 右旋示意图(对节点y进行右旋)：</span><br><span class="line">     *            py                               py</span><br><span class="line">     *           /                                /</span><br><span class="line">     *          y                                x                 </span><br><span class="line">     *         /  \      --(右旋)--            /  \                     </span><br><span class="line">     *        x   ry                           lx   y </span><br><span class="line">     *       / \                                   / \                   </span><br><span class="line">     *      lx  rx                                rx  ry</span><br><span class="line">     *</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rotateRight</span><span class="params">(Entry&lt;K,V&gt; p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 取得要选择节点p的左孩子</span></span><br><span class="line">            Entry&lt;K,V&gt; l = p. left;           </span><br><span class="line">            <span class="comment">// 将"l的右孩子"设为"p的左孩子"</span></span><br><span class="line">            p. left = l.right ;</span><br><span class="line">            <span class="comment">// 如果"l的右孩子"不为空的话，将"p"设为"l的右孩子的父亲"</span></span><br><span class="line">            <span class="keyword">if</span> (l.right != <span class="keyword">null</span>) l. right.parent = p;</span><br><span class="line">            <span class="comment">// 将"p的父亲"设为"l的父亲"</span></span><br><span class="line">            l. parent = p.parent ;</span><br><span class="line">            <span class="comment">// 如果"p的父亲"是空节点，则将l设为根节点</span></span><br><span class="line">            <span class="keyword">if</span> (p.parent == <span class="keyword">null</span>)</span><br><span class="line">                root = l;      </span><br><span class="line">            <span class="comment">// 如果p是它父节点的右孩子，则将l设为"p的父节点的右孩子"</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p.parent. right == p)</span><br><span class="line">                p. parent.right = l;</span><br><span class="line">            <span class="comment">//如果p是它父节点的左孩子，将l设为"p的父节点的左孩子"</span></span><br><span class="line">            <span class="keyword">else</span> p.parent .left = l;</span><br><span class="line">            <span class="comment">// 将"p"设为"l的右孩子"</span></span><br><span class="line">            l. right = p;</span><br><span class="line">            <span class="comment">// 将"l"设为"p父节点"</span></span><br><span class="line">            p. parent = l;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>单纯的看代码和注释，绝对会发出，cha这是什么乱七八糟的，任谁也看不懂，所以一定要结合上面的图解，不懂了就看看图，然后动手画一下。</p>
<h3 id="红黑树的删除原理及TreeMap的remove实现"><a href="#红黑树的删除原理及TreeMap的remove实现" class="headerlink" title="红黑树的删除原理及TreeMap的remove实现"></a>红黑树的删除原理及TreeMap的remove实现</h3><p>相比添加，红黑树的删除显得更加复杂了。看下红黑树的删除需要哪几个步奏：</p>
<ul>
<li>将红黑树当成一颗二叉查找树，将节点删除。</li>
<li>通过旋转和着色，使它恢复平衡，重新变成一颗符合规则的红黑树。</li>
</ul>
<p>删除节点的关键是：</p>
<ul>
<li>如果删除的是红色节点，不会违背红黑树的规则。</li>
<li>如果删除的是黑色节点，那么这个路径上就少了一个黑色节点，则违背了红黑树的规则。</li>
</ul>
<p>来看下红黑树删除节点会有哪几种情况：<br>（1）被删除的节点没有孩子节点，即叶子节点。可直接删除。<br>（2）被删除的节点只有一个孩子节点，那么直接删除该节点，然后用它的孩子节点顶替它的位置。<br>（3）被删除的节点有两个孩子节点。这种情况二叉树的删除有一个技巧，就是查找到要删除的节点X，接着我们找到它左子树的最大元素M，或者它右子树的最小元素M，交换X和M的值，然后删除节点M。此时M就最多只有一个子节点N(若是左子树则没有右子节点，若是右子树则没有左子节点 )，若M没有孩子则进入(1)的情况，否则进入(2)的情况。<br><img src="http://7xqch5.com1.z0.glb.clouddn.com/jh4_13.jpg" alt=""><br>如上图，我们假定节点X是要删除的节点，而节点M是找到X右子树的最小元素，所以节点M是X的替代节点，也就是说M是真正要删除的节点。上面我们分析了此时的M只会有一个子节点N，当删除节点M后，N将替代M作为M节点的父节点的子节点。删除的节点M是黑色（删除红色不影响上面分析了），此时如果N是红色，只需将N设置为黑色，就会重新达到平衡，不会出现该路径上少了一个黑色节点的情况；但是如果N是红色，情况则比较复杂，需要对红黑树进行调整，而这种情况又分为了以下几种，下面进行图解：<br>①N的兄弟节点B是红色。方法是：<strong>交换P和B的颜色，左旋父节点P</strong>。此时并未完成平衡，左子树仍然少了一个黑色节点，进入情况③。（B为红色，P必然为黑色）<br><img src="http://7xqch5.com1.z0.glb.clouddn.com/jh4_14.jpg" alt=""></p>
<p>②N的父节点P是黑色，且兄弟节点B和它的两个孩子节点也都是黑色。方法是：<strong>将N的兄弟节点B改为红色</strong>，这样从P出发到叶子节点的路径都包含了相同的黑色节点，<strong>但是</strong>，对于节点P这个子树，P的父节点G到P的叶子节点路径上的黑色节点就少了一个，<strong>此时需要将P整体看做一个节点，继续调整</strong>。<br><img src="http://7xqch5.com1.z0.glb.clouddn.com/jh4_15.jpg" alt=""><br>③N的父节点P为红色，兄弟节点B和它的两个孩子节点也都是黑色。<strong>此时只需要交换P和B的颜色，将P改为黑色，B改为红色，则可到达平衡</strong>。这相当于既然节点N路径少了一个黑色节点，那么B路径也少一个黑色节点，这两个路径达到平衡，为了防止P路径少一个黑色节点，将P节点置黑，则达到最终平衡。<br><img src="http://7xqch5.com1.z0.glb.clouddn.com/jh4_16.jpg" alt=""><br>④N的兄弟节点B是黑色，B的左孩子节点BL是红色，B的右孩子节点BR是黑色，P为任意颜色。方法是：交换B和BL的颜色，右旋节点B。此时N子树路径并没有增加黑色节点，也就是没有达到平衡，此时进入下一种情况⑤。<br><img src="http://7xqch5.com1.z0.glb.clouddn.com/jh4_17.jpg" alt=""><br><img src="http://7xqch5.com1.z0.glb.clouddn.com/jh4_18.jpg" alt=""><br>⑤N的兄弟节点B是黑色，B的右孩子节点BR是红色，B的左孩子节点BL任意颜色，P任意颜色。方法是：BR变为黑色，P变为黑色，B变为P的颜色；左旋节点B。首先给N路径增加一个黑色节点P，P原位置上的颜色不变；S路径少了一个黑色节点，于是将BR改为黑色，最终达到了平衡。<br><img src="http://7xqch5.com1.z0.glb.clouddn.com/jh4_19.jpg" alt=""></p>
<p>上面对红黑树删除的原理和删除过程中遇到的情况进行了分析说明，我们得到的结论是红黑树的删除遇到的主要问题就是被删除路径上的黑色节点减少，于是需要进行一系列旋转和着色，<strong>当然上面的情况是基于M是X右子树的最小元素，而M如果是X左子树的最大元素和上面的情况是相似的</strong>，我们具体看下TreeMap的代码是怎么实现的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 根据key查找到对应的节点对象</span></span><br><span class="line">        Entry&lt;K,V&gt; p = getEntry(key);</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记录key对应的value，供返回使用</span></span><br><span class="line">        V oldValue = p. value;</span><br><span class="line">        <span class="comment">// 删除节点</span></span><br><span class="line">        deleteEntry(p);</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">deleteEntry</span><span class="params">(Entry&lt;K,V&gt; p)</span> </span>&#123;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="comment">// map容器的元素个数减一</span></span><br><span class="line">        size--;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If strictly internal, copy successor's element to p and then make p</span></span><br><span class="line">        <span class="comment">// point to successor.</span></span><br><span class="line">        <span class="comment">// 如果被删除的节点p的左孩子和右孩子都不为空，则查找其替代节点-----------这里表示要删除的节点有两个孩子（3）</span></span><br><span class="line">        <span class="keyword">if</span> (p.left != <span class="keyword">null</span> &amp;&amp; p. right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 查找p的替代节点</span></span><br><span class="line">            Entry&lt;K,V&gt; s = successor (p);</span><br><span class="line">            p. key = s.key ;</span><br><span class="line">            p. value = s.value ;</span><br><span class="line">            <span class="comment">// 将p指向替代节点，※※※※※※从此之后的p不再是原先要删除的节点p，而是替代者p（就是图解里面讲到的M） ※※※※※※</span></span><br><span class="line">            p = s;</span><br><span class="line">        &#125; <span class="comment">// p has 2 children</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Start fixup at replacement node, if it exists.</span></span><br><span class="line">        <span class="comment">// replacement为替代节点p的继承者（就是图解里面讲到的N），p的左孩子存在则用p的左孩子替代，否则用p的右孩子</span></span><br><span class="line">        Entry&lt;K,V&gt; replacement = (p. left != <span class="keyword">null</span> ? p.left : p. right);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (replacement != <span class="keyword">null</span>) &#123; <span class="comment">// 如果上面的if有两个孩子不通过--------------这里表示要删除的节点只有一个孩子（2）</span></span><br><span class="line">            <span class="comment">// Link replacement to parent</span></span><br><span class="line">            <span class="comment">// 将p的父节点拷贝给替代节点</span></span><br><span class="line">            replacement. parent = p.parent ;</span><br><span class="line">            <span class="comment">// 如果替代节点p的父节点为空，也就是p为跟节点，则将replacement设置为根节点</span></span><br><span class="line">            <span class="keyword">if</span> (p.parent == <span class="keyword">null</span>)</span><br><span class="line">                root = replacement;</span><br><span class="line">            <span class="comment">// 如果替代节点p是其父节点的左孩子，则将replacement设置为其父节点的左孩子</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p == p.parent. left)</span><br><span class="line">                p. parent.left   = replacement;</span><br><span class="line">            <span class="comment">// 如果替代节点p是其父节点的左孩子，则将replacement设置为其父节点的右孩子</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                p. parent.right = replacement;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Null out links so they are OK to use by fixAfterDeletion.</span></span><br><span class="line">            <span class="comment">// 将替代节点p的left、right、parent的指针都指向空，即解除前后引用关系（相当于将p从树种摘除），使得gc可以回收</span></span><br><span class="line">            p. left = p.right = p.parent = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Fix replacement</span></span><br><span class="line">            <span class="comment">// 如果替代节点p的颜色是黑色，则需要调整红黑树以保持其平衡</span></span><br><span class="line">            <span class="keyword">if</span> (p.color == BLACK)</span><br><span class="line">                fixAfterDeletion(replacement);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p.parent == <span class="keyword">null</span>) &#123; <span class="comment">// return if we are the only node.</span></span><br><span class="line">            <span class="comment">// 如果要替代节点p没有父节点，代表p为根节点，直接删除即可</span></span><br><span class="line">            root = <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">//  No children. Use self as phantom replacement and unlink.</span></span><br><span class="line">            <span class="comment">// 判断进入这里说明替代节点p没有孩子--------------这里表示没有孩子则直接删除（1）</span></span><br><span class="line">            <span class="comment">// 如果p的颜色是黑色，则调整红黑树</span></span><br><span class="line">            <span class="keyword">if</span> (p.color == BLACK)</span><br><span class="line">                fixAfterDeletion(p);</span><br><span class="line">            <span class="comment">// 下面删除替代节点p</span></span><br><span class="line">            <span class="keyword">if</span> (p.parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 解除p的父节点对p的引用</span></span><br><span class="line">                <span class="keyword">if</span> (p == p.parent .left)</span><br><span class="line">                    p. parent.left = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (p == p.parent. right)</span><br><span class="line">                    p. parent.right = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">// 解除p对p父节点的引用</span></span><br><span class="line">                p. parent = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 查找要删除节点的替代节点</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">static</span> &lt;K,V&gt; TreeMap.Entry&lt;K,V&gt; successor(Entry&lt;K,V&gt; t) &#123;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 查找右子树的最左孩子</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (t.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; p = t. right;</span><br><span class="line">            <span class="keyword">while</span> (p.left != <span class="keyword">null</span>)</span><br><span class="line">                p = p. left;</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 查找左子树的最右孩子</span></span><br><span class="line">            Entry&lt;K,V&gt; p = t. parent;</span><br><span class="line">            Entry&lt;K,V&gt; ch = t;</span><br><span class="line">            <span class="keyword">while</span> (p != <span class="keyword">null</span> &amp;&amp; ch == p. right) &#123;</span><br><span class="line">                ch = p;</span><br><span class="line">                p = p. parent;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** From CLR */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fixAfterDeletion</span><span class="params">(Entry&lt;K,V&gt; x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// while循环，保证要删除节点x不是跟节点，并且是黑色（根节点和红色不需要调整）</span></span><br><span class="line">        <span class="keyword">while</span> (x != root &amp;&amp; colorOf (x) == BLACK) &#123;</span><br><span class="line">            <span class="comment">// 如果要删除节点x是其父亲的左孩子</span></span><br><span class="line">            <span class="keyword">if</span> (x == leftOf( parentOf(x))) &#123;</span><br><span class="line">                <span class="comment">// 取出要删除节点x的兄弟节点</span></span><br><span class="line">                Entry&lt;K,V&gt; sib = rightOf(parentOf (x));</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果删除节点x的兄弟节点是红色---------------------------①</span></span><br><span class="line">                <span class="keyword">if</span> (colorOf(sib) == RED) &#123;</span><br><span class="line">                    <span class="comment">// 将x的兄弟节点颜色设置为黑色</span></span><br><span class="line">                    setColor(sib, BLACK);</span><br><span class="line">                    <span class="comment">// 将x的父节点颜色设置为红色</span></span><br><span class="line">                    setColor(parentOf (x), RED);</span><br><span class="line">                    <span class="comment">// 左旋x的父节点</span></span><br><span class="line">                    rotateLeft( parentOf(x));</span><br><span class="line">                    <span class="comment">// 将sib重新指向旋转后x的兄弟节点 ，进入else的步奏③</span></span><br><span class="line">                    sib = rightOf(parentOf (x));</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果x的兄弟节点的两个孩子都是黑色-------------------------③</span></span><br><span class="line">                <span class="keyword">if</span> (colorOf(leftOf(sib))  == BLACK &amp;&amp;</span><br><span class="line">                    colorOf(rightOf (sib)) == BLACK) &#123;</span><br><span class="line">                    <span class="comment">// 将兄弟节点的颜色设置为红色</span></span><br><span class="line">                    setColor(sib, RED);</span><br><span class="line">                    <span class="comment">// 将x的父节点指向x，如果x的父节点是黑色，需要将x的父节点整天看做一个节点继续调整-------------------------②</span></span><br><span class="line">                    x = parentOf(x);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 如果x的兄弟节点右孩子是黑色，左孩子是红色-------------------------④</span></span><br><span class="line">                    <span class="keyword">if</span> (colorOf(rightOf(sib)) == BLACK) &#123;</span><br><span class="line">                        <span class="comment">// 将x的兄弟节点的左孩子设置为黑色</span></span><br><span class="line">                        setColor(leftOf (sib), BLACK);</span><br><span class="line">                        <span class="comment">// 将x的兄弟节点设置为红色</span></span><br><span class="line">                        setColor(sib, RED);</span><br><span class="line">                        <span class="comment">// 右旋x的兄弟节点</span></span><br><span class="line">                        rotateRight(sib);</span><br><span class="line">                        <span class="comment">// 将sib重新指向旋转后x的兄弟节点，进入步奏⑤</span></span><br><span class="line">                        sib = rightOf(parentOf (x));</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 如果x的兄弟节点右孩子是红色-------------------------⑤</span></span><br><span class="line">                    setColor(sib, colorOf (parentOf(x)));</span><br><span class="line">                    <span class="comment">// 将x的父节点设置为黑色</span></span><br><span class="line">                    setColor(parentOf (x), BLACK);</span><br><span class="line">                    <span class="comment">// 将x的兄弟节点的右孩子设置为黑色</span></span><br><span class="line">                    setColor(rightOf (sib), BLACK);</span><br><span class="line">                    <span class="comment">// 左旋x的父节点</span></span><br><span class="line">                    rotateLeft( parentOf(x));</span><br><span class="line">                    <span class="comment">// 达到平衡，将x指向root，退出循环</span></span><br><span class="line">                    x = root;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// symmetric // 如果要删除节点x是其父亲的右孩子，和上面情况一样，这里不再细讲</span></span><br><span class="line">                Entry&lt;K,V&gt; sib = leftOf(parentOf (x));</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (colorOf(sib) == RED) &#123;</span><br><span class="line">                    setColor(sib, BLACK);</span><br><span class="line">                    setColor(parentOf (x), RED);</span><br><span class="line">                    rotateRight( parentOf(x));</span><br><span class="line">                    sib = leftOf(parentOf (x));</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (colorOf(rightOf(sib)) == BLACK &amp;&amp;</span><br><span class="line">                    colorOf(leftOf (sib)) == BLACK) &#123;</span><br><span class="line">                    setColor(sib, RED);</span><br><span class="line">                    x = parentOf(x);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (colorOf(leftOf(sib)) == BLACK) &#123;</span><br><span class="line">                        setColor(rightOf (sib), BLACK);</span><br><span class="line">                        setColor(sib, RED);</span><br><span class="line">                        rotateLeft(sib);</span><br><span class="line">                        sib = leftOf(parentOf (x));</span><br><span class="line">                    &#125;</span><br><span class="line">                    setColor(sib, colorOf (parentOf(x)));</span><br><span class="line">                    setColor(parentOf (x), BLACK);</span><br><span class="line">                    setColor(leftOf (sib), BLACK);</span><br><span class="line">                    rotateRight( parentOf(x));</span><br><span class="line">                    x = root;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        setColor(x, BLACK);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>删除相对来说更加复杂，还是那句话一定要对照着图解看代码，否则是读不懂的，别问我是怎么看懂得，我n天不看再看代码也不知道123了。<br>终于看完了红黑树的增加和删除，下面来看个稍微简单的查询：</p>
<h3 id="红黑树的查询"><a href="#红黑树的查询" class="headerlink" title="红黑树的查询"></a>红黑树的查询</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        Entry&lt;K,V&gt; p = getEntry(key);</span><br><span class="line">        <span class="keyword">return</span> (p==<span class="keyword">null</span> ? <span class="keyword">null</span> : p. value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> Entry&lt;K,V&gt; getEntry(Object key) &#123;</span><br><span class="line">        <span class="comment">// Offload comparator-based version for sake of performance</span></span><br><span class="line">        <span class="keyword">if</span> (comparator != <span class="keyword">null</span>)</span><br><span class="line">            <span class="comment">// 如果比较器为空，只是用key作为比较器查询</span></span><br><span class="line">            <span class="keyword">return</span> getEntryUsingComparator(key);</span><br><span class="line">        <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">       Comparable&lt;? <span class="keyword">super</span> K&gt; k = (Comparable&lt;? <span class="keyword">super</span> K&gt;) key;</span><br><span class="line">        <span class="comment">// 取得root节点</span></span><br><span class="line">        Entry&lt;K,V&gt; p = root;</span><br><span class="line">        <span class="comment">// 从root节点开始查找，根据比较器判断是在左子树还是右子树</span></span><br><span class="line">        <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> cmp = k.compareTo(p.key );</span><br><span class="line">            <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">                p = p. left;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">                p = p. right;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Entry&lt;K,V&gt; getEntryUsingComparator(Object key) &#123;</span><br><span class="line">       K k = (K) key;</span><br><span class="line">        Comparator&lt;? <span class="keyword">super</span> K&gt; cpr = comparator ;</span><br><span class="line">        <span class="keyword">if</span> (cpr != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; p = root;</span><br><span class="line">            <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> cmp = cpr.compare(k, p.key );</span><br><span class="line">                <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">                    p = p. left;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">                    p = p. right;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">return</span> p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="TreeMap遍历方式"><a href="#TreeMap遍历方式" class="headerlink" title="TreeMap遍历方式"></a>TreeMap遍历方式</h3><h4 id="遍历TreeMap的键值对"><a href="#遍历TreeMap的键值对" class="headerlink" title="遍历TreeMap的键值对"></a>遍历TreeMap的键值对</h4><p>第一步：根据entrySet()获取TreeMap的“键值对”的Set集合。<br>第二步：通过Iterator迭代器遍历“第一步”得到的集合。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设map是TreeMap对象</span></span><br><span class="line"><span class="comment">// map中的key是String类型，value是Integer类型</span></span><br><span class="line">Integer integ = <span class="keyword">null</span>;</span><br><span class="line">Iterator iter = map.entrySet().iterator();</span><br><span class="line"><span class="keyword">while</span>(iter.hasNext()) &#123;</span><br><span class="line">    Map.Entry entry = (Map.Entry)iter.next();</span><br><span class="line">    <span class="comment">// 获取key</span></span><br><span class="line">    key = (String)entry.getKey();</span><br><span class="line">        <span class="comment">// 获取value</span></span><br><span class="line">    integ = (Integer)entry.getValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="遍历TreeMap的键"><a href="#遍历TreeMap的键" class="headerlink" title="遍历TreeMap的键"></a>遍历TreeMap的键</h4><p>第一步：根据keySet()获取TreeMap的“键”的Set集合。<br>第二步：通过Iterator迭代器遍历“第一步”得到的集合。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设map是TreeMap对象</span></span><br><span class="line"><span class="comment">// map中的key是String类型，value是Integer类型</span></span><br><span class="line">String key = <span class="keyword">null</span>;</span><br><span class="line">Integer integ = <span class="keyword">null</span>;</span><br><span class="line">Iterator iter = map.keySet().iterator();</span><br><span class="line"><span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">        <span class="comment">// 获取key</span></span><br><span class="line">    key = (String)iter.next();</span><br><span class="line">        <span class="comment">// 根据key，获取value</span></span><br><span class="line">    integ = (Integer)map.get(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="遍历TreeMap的值"><a href="#遍历TreeMap的值" class="headerlink" title="遍历TreeMap的值"></a>遍历TreeMap的值</h4><p>第一步：根据value()获取TreeMap的“值”的集合。<br>第二步：通过Iterator迭代器遍历“第一步”得到的集合。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设map是TreeMap对象</span></span><br><span class="line"><span class="comment">// map中的key是String类型，value是Integer类型</span></span><br><span class="line">Integer value = <span class="keyword">null</span>;</span><br><span class="line">Collection c = map.values();</span><br><span class="line">Iterator iter= c.iterator();</span><br><span class="line"><span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">    value = (Integer)iter.next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="TreeMap示例"><a href="#TreeMap示例" class="headerlink" title="TreeMap示例"></a>TreeMap示例</h3><p>下面通过实例来学习如何使用TreeMap<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * <span class="doctag">@desc</span> TreeMap测试程序 </span><br><span class="line"> *</span><br><span class="line"> * <span class="doctag">@author</span> skywang</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeMapTest</span>  </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 测试常用的API</span></span><br><span class="line">        testTreeMapOridinaryAPIs();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 测试TreeMap的导航函数</span></span><br><span class="line">        <span class="comment">//testNavigableMapAPIs();</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 测试TreeMap的子Map函数</span></span><br><span class="line">        <span class="comment">//testSubMapAPIs();</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 测试常用的API</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testTreeMapOridinaryAPIs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 初始化随机种子</span></span><br><span class="line">        Random r = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="comment">// 新建TreeMap</span></span><br><span class="line">        TreeMap tmap = <span class="keyword">new</span> TreeMap();</span><br><span class="line">        <span class="comment">// 添加操作</span></span><br><span class="line">        tmap.put(<span class="string">"one"</span>, r.nextInt(<span class="number">10</span>));</span><br><span class="line">        tmap.put(<span class="string">"two"</span>, r.nextInt(<span class="number">10</span>));</span><br><span class="line">        tmap.put(<span class="string">"three"</span>, r.nextInt(<span class="number">10</span>));</span><br><span class="line"></span><br><span class="line">        System.out.printf(<span class="string">"\n ---- testTreeMapOridinaryAPIs ----\n"</span>);</span><br><span class="line">        <span class="comment">// 打印出TreeMap</span></span><br><span class="line">        System.out.printf(<span class="string">"%s\n"</span>,tmap );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过Iterator遍历key-value</span></span><br><span class="line">        Iterator iter = tmap.entrySet().iterator();</span><br><span class="line">        <span class="keyword">while</span>(iter.hasNext()) &#123;</span><br><span class="line">            Map.Entry entry = (Map.Entry)iter.next();</span><br><span class="line">            System.out.printf(<span class="string">"next : %s - %s\n"</span>, entry.getKey(), entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// TreeMap的键值对个数        </span></span><br><span class="line">        System.out.printf(<span class="string">"size: %s\n"</span>, tmap.size());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// containsKey(Object key) :是否包含键key</span></span><br><span class="line">        System.out.printf(<span class="string">"contains key two : %s\n"</span>,tmap.containsKey(<span class="string">"two"</span>));</span><br><span class="line">        System.out.printf(<span class="string">"contains key five : %s\n"</span>,tmap.containsKey(<span class="string">"five"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// containsValue(Object value) :是否包含值value</span></span><br><span class="line">        System.out.printf(<span class="string">"contains value 0 : %s\n"</span>,tmap.containsValue(<span class="keyword">new</span> Integer(<span class="number">0</span>)));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// remove(Object key) ： 删除键key对应的键值对</span></span><br><span class="line">        tmap.remove(<span class="string">"three"</span>);</span><br><span class="line"></span><br><span class="line">        System.out.printf(<span class="string">"tmap:%s\n"</span>,tmap );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// clear() ： 清空TreeMap</span></span><br><span class="line">        tmap.clear();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// isEmpty() : TreeMap是否为空</span></span><br><span class="line">        System.out.printf(<span class="string">"%s\n"</span>, (tmap.isEmpty()?<span class="string">"tmap is empty"</span>:<span class="string">"tmap is not empty"</span>) );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 测试TreeMap的子Map函数</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testSubMapAPIs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 新建TreeMap</span></span><br><span class="line">        TreeMap tmap = <span class="keyword">new</span> TreeMap();</span><br><span class="line">        <span class="comment">// 添加“键值对”</span></span><br><span class="line">        tmap.put(<span class="string">"a"</span>, <span class="number">101</span>);</span><br><span class="line">        tmap.put(<span class="string">"b"</span>, <span class="number">102</span>);</span><br><span class="line">        tmap.put(<span class="string">"c"</span>, <span class="number">103</span>);</span><br><span class="line">        tmap.put(<span class="string">"d"</span>, <span class="number">104</span>);</span><br><span class="line">        tmap.put(<span class="string">"e"</span>, <span class="number">105</span>);</span><br><span class="line"></span><br><span class="line">        System.out.printf(<span class="string">"\n ---- testSubMapAPIs ----\n"</span>);</span><br><span class="line">        <span class="comment">// 打印出TreeMap</span></span><br><span class="line">        System.out.printf(<span class="string">"tmap:\n\t%s\n"</span>, tmap);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 测试 headMap(K toKey)</span></span><br><span class="line">        System.out.printf(<span class="string">"tmap.headMap(\"c\"):\n\t%s\n"</span>, tmap.headMap(<span class="string">"c"</span>));</span><br><span class="line">        <span class="comment">// 测试 headMap(K toKey, boolean inclusive) </span></span><br><span class="line">        System.out.printf(<span class="string">"tmap.headMap(\"c\", true):\n\t%s\n"</span>, tmap.headMap(<span class="string">"c"</span>, <span class="keyword">true</span>));</span><br><span class="line">        System.out.printf(<span class="string">"tmap.headMap(\"c\", false):\n\t%s\n"</span>, tmap.headMap(<span class="string">"c"</span>, <span class="keyword">false</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 测试 tailMap(K fromKey)</span></span><br><span class="line">        System.out.printf(<span class="string">"tmap.tailMap(\"c\"):\n\t%s\n"</span>, tmap.tailMap(<span class="string">"c"</span>));</span><br><span class="line">        <span class="comment">// 测试 tailMap(K fromKey, boolean inclusive)</span></span><br><span class="line">        System.out.printf(<span class="string">"tmap.tailMap(\"c\", true):\n\t%s\n"</span>, tmap.tailMap(<span class="string">"c"</span>, <span class="keyword">true</span>));</span><br><span class="line">        System.out.printf(<span class="string">"tmap.tailMap(\"c\", false):\n\t%s\n"</span>, tmap.tailMap(<span class="string">"c"</span>, <span class="keyword">false</span>));</span><br><span class="line">   </span><br><span class="line">        <span class="comment">// 测试 subMap(K fromKey, K toKey)</span></span><br><span class="line">        System.out.printf(<span class="string">"tmap.subMap(\"a\", \"c\"):\n\t%s\n"</span>, tmap.subMap(<span class="string">"a"</span>, <span class="string">"c"</span>));</span><br><span class="line">        <span class="comment">// 测试 </span></span><br><span class="line">        System.out.printf(<span class="string">"tmap.subMap(\"a\", true, \"c\", true):\n\t%s\n"</span>, </span><br><span class="line">                tmap.subMap(<span class="string">"a"</span>, <span class="keyword">true</span>, <span class="string">"c"</span>, <span class="keyword">true</span>));</span><br><span class="line">        System.out.printf(<span class="string">"tmap.subMap(\"a\", true, \"c\", false):\n\t%s\n"</span>, </span><br><span class="line">                tmap.subMap(<span class="string">"a"</span>, <span class="keyword">true</span>, <span class="string">"c"</span>, <span class="keyword">false</span>));</span><br><span class="line">        System.out.printf(<span class="string">"tmap.subMap(\"a\", false, \"c\", true):\n\t%s\n"</span>, </span><br><span class="line">                tmap.subMap(<span class="string">"a"</span>, <span class="keyword">false</span>, <span class="string">"c"</span>, <span class="keyword">true</span>));</span><br><span class="line">        System.out.printf(<span class="string">"tmap.subMap(\"a\", false, \"c\", false):\n\t%s\n"</span>, </span><br><span class="line">                tmap.subMap(<span class="string">"a"</span>, <span class="keyword">false</span>, <span class="string">"c"</span>, <span class="keyword">false</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 测试 navigableKeySet()</span></span><br><span class="line">        System.out.printf(<span class="string">"tmap.navigableKeySet():\n\t%s\n"</span>, tmap.navigableKeySet());</span><br><span class="line">        <span class="comment">// 测试 descendingKeySet()</span></span><br><span class="line">        System.out.printf(<span class="string">"tmap.descendingKeySet():\n\t%s\n"</span>, tmap.descendingKeySet());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 测试TreeMap的导航函数</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testNavigableMapAPIs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 新建TreeMap</span></span><br><span class="line">        NavigableMap nav = <span class="keyword">new</span> TreeMap();</span><br><span class="line">        <span class="comment">// 添加“键值对”</span></span><br><span class="line">        nav.put(<span class="string">"aaa"</span>, <span class="number">111</span>);</span><br><span class="line">        nav.put(<span class="string">"bbb"</span>, <span class="number">222</span>);</span><br><span class="line">        nav.put(<span class="string">"eee"</span>, <span class="number">333</span>);</span><br><span class="line">        nav.put(<span class="string">"ccc"</span>, <span class="number">555</span>);</span><br><span class="line">        nav.put(<span class="string">"ddd"</span>, <span class="number">444</span>);</span><br><span class="line"></span><br><span class="line">        System.out.printf(<span class="string">"\n ---- testNavigableMapAPIs ----\n"</span>);</span><br><span class="line">        <span class="comment">// 打印出TreeMap</span></span><br><span class="line">        System.out.printf(<span class="string">"Whole list:%s%n"</span>, nav);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取第一个key、第一个Entry</span></span><br><span class="line">        System.out.printf(<span class="string">"First key: %s\tFirst entry: %s%n"</span>,nav.firstKey(), nav.firstEntry());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取最后一个key、最后一个Entry</span></span><br><span class="line">        System.out.printf(<span class="string">"Last key: %s\tLast entry: %s%n"</span>,nav.lastKey(), nav.lastEntry());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取“小于/等于bbb”的最大键值对</span></span><br><span class="line">        System.out.printf(<span class="string">"Key floor before bbb: %s%n"</span>,nav.floorKey(<span class="string">"bbb"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取“小于bbb”的最大键值对</span></span><br><span class="line">        System.out.printf(<span class="string">"Key lower before bbb: %s%n"</span>, nav.lowerKey(<span class="string">"bbb"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取“大于/等于bbb”的最小键值对</span></span><br><span class="line">        System.out.printf(<span class="string">"Key ceiling after ccc: %s%n"</span>,nav.ceilingKey(<span class="string">"ccc"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取“大于bbb”的最小键值对</span></span><br><span class="line">        System.out.printf(<span class="string">"Key higher after ccc: %s%n\n"</span>,nav.higherKey(<span class="string">"ccc"</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;one=<span class="number">8</span>, three=<span class="number">4</span>, two=<span class="number">2</span>&#125;</span><br><span class="line">next : one - <span class="number">8</span></span><br><span class="line">next : three - <span class="number">4</span></span><br><span class="line">next : two - <span class="number">2</span></span><br><span class="line">size: <span class="number">3</span></span><br><span class="line">contains key two : <span class="keyword">true</span></span><br><span class="line">contains key five : <span class="keyword">false</span></span><br><span class="line">contains value <span class="number">0</span> : <span class="keyword">false</span></span><br><span class="line">tmap:&#123;one=<span class="number">8</span>, two=<span class="number">2</span>&#125;</span><br><span class="line">tmap is empty</span><br></pre></td></tr></table></figure></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>到此TreeMap就分析完了，其实大部分时间都在整理红黑树，在数据结构中树是比较难懂的一个，其算法也比较复杂，对于树的理解一定要多看图画图，要明白这么做是为了解决什么问题，这么做又有什么好处，当然看一遍看不懂就要多看几遍了。什么你问我平时工作中会用到树吗？那真的要看你做的什么性质的工作，如果是web、客户端开发，调用api就可以了对吧，如果是从事底层开发，比如文件系统，存储系统，缓存等工作必须是需要的。当然就算用不到，理解了也是有益无害的。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>该文为本人学习的笔记，方便以后自己跳槽前复习。参考网上各大帖子，取其精华整合自己的理解而成。集合框架源码面试经常会问，所以解读源码十分必要,希望对你有用。<br><a href="http://www.cnblogs.com/chenssy/p/3746600.html" target="_blank" rel="external">Java提高篇（二七）—–TreeMap</a><br><a href="http://www.cnblogs.com/skywang12345/p/3310928.html" target="_blank" rel="external">Java 集合系列12之 TreeMap详细介绍(源码解析)和使用示例</a><br><a href="http://www.cnblogs.com/tstd/p/5081237.html" target="_blank" rel="external">给jdk写注释系列之jdk1.6容器(7)-TreeMap源码解析</a><br><a href="http://www.tuicool.com/articles/J3iMf2R" target="_blank" rel="external">红黑树(五)之 Java的实现 - 如果天空不死</a></p>
<h1 id="整理的集合框架思维导图"><a href="#整理的集合框架思维导图" class="headerlink" title="整理的集合框架思维导图"></a>整理的集合框架思维导图</h1><p>个人整理的Java集合框架思维导图，动态维护。导出的图片无法查看备注的一些信息，所以需要源文件的童鞋可以关注我个人主页上的公众号，回复<strong>Java集合框架</strong>即可获取源文件。<br><img src="http://7xqch5.com1.z0.glb.clouddn.com/jhswdt.png" alt=""></p>
<hr>
<p>博主弄了个java学习资源的公众号，学习资源超级多，视频，电子书，最新开发工具一个都不能少，已全部分享到百度云盘，求资源共享，打造一个学习方便，工作方便的java公众号，开源开源，有需求的可以关注~撒花<br>  <img src="http://7xqch5.com1.z0.glb.clouddn.com/javaLearn.PNG" alt=""></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Java集合干货系列/">Java集合干货系列</a>
    </div>


      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-javajh3hashmap" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/04/15/javajh3hashmap/" class="article-date">
      <time datetime="2016-04-15T01:09:14.000Z" itemprop="datePublished">2016-04-15</time>
</a>

 
    <a href="/2016/04/15/javajh3hashmap/#comments" title="查看评论">
        <i class="fa fa-comments-o" aria-hidden="true"></i>
        <span class="count-comment"></span>
        
            <span class="ds-thread-count"  data-thread-key="2016/04/15/javajh3hashmap/" ></span>
        
        
    </a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/15/javajh3hashmap/">Java集合干货系列-（三）HashMap源码解析</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>今天来介绍下HashMap，之前的List，讲了ArrayList、LinkedList，就前两者而言，反映的是两种思想：</p>
<ul>
<li>ArrayList以数组形式实现，顺序插入、查找快，插入、删除较慢</li>
<li>LinkedList以链表形式实现，顺序插入、查找较慢，插入、删除方便</li>
</ul>
<p>那么是否有一种数据结构能够结合上面两种的优点呢？有，答案就是HashMap。它是基于哈希表的 Map 接口的实现，以key-value的形式存在。<br>构造图如下:<br>蓝色线条：继承<br>绿色线条：接口实现<br><img src="http://7xqch5.com1.z0.glb.clouddn.com/jh3_1.png" alt=""></p>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>要理解HashMap， 就必须要知道了解其底层的实现， 而底层实现里最重要的就是它的数据结构了，<strong>HashMap实际上是一个“链表散列”的数据结构，即数组和链表的结合体</strong>。</p>
<p>在分析要理解HashMap源码前有必要对hashcode进行说明。<br>以下是关于HashCode的官方文档定义：</p>
<blockquote>
<p>hashcode方法返回该对象的哈希码值。支持该方法是为哈希表提供一些优点，例如，java.util.Hashtable 提供的哈希表。<br>hashCode 的常规协定是：<br>在 Java 应用程序执行期间，在同一对象上多次调用 hashCode 方法时，必须一致地返回相同的整数，前提是对象上 equals 比较中所用的信息没有被修改。从某一应用程序的一次执行到同一应用程序的另一次执行，该整数无需保持一致。   </p>
<p>如果根据 equals(Object) 方法，两个对象是相等的，那么在两个对象中的每个对象上调用 hashCode 方法都必须生成相同的整数结果。   </p>
<p>以下情况不 是必需的：如果根据 equals(java.lang.Object) 方法，两个对象不相等，那么在两个对象中的任一对象上调用 hashCode 方法必定会生成不同的整数结果。但是，程序员应该知道，为不相等的对象生成不同整数结果可以提高哈希表的性能。   </p>
<p>实际上，由 Object 类定义的 hashCode 方法确实会针对不同的对象返回不同的整数。（这一般是通过将该对象的内部地址转换成一个整数来实现的，但是 JavaTM 编程语言不需要这种实现技巧。）   </p>
<p>当equals方法被重写时，通常有必要重写 hashCode 方法，以维护 hashCode 方法的常规协定，该协定声明相等对象必须具有相等的哈希码。</p>
</blockquote>
<p>以上这段官方文档的定义，我们可以抽出成以下几个关键点：</p>
<ol>
<li><p>hashCode的存在主要是用于查找的快捷性，如Hashtable，HashMap等，hashCode是用来在散列存储结构中确定对象的存储地址的；</p>
</li>
<li><p>如果两个对象相同，就是适用于equals(java.lang.Object) 方法，那么这两个对象的hashCode一定要相同；</p>
</li>
<li><p>如果对象的equals方法被重写，那么对象的hashCode也尽量重写，并且产生hashCode使用的对象，一定要和equals方法中使用的一致，否则就会违反上面提到的第2点；</p>
</li>
<li><p>两个对象的hashCode相同，并不一定表示两个对象就相同，也就是不一定适用于equals(java.lang.Object) 方法，只能够说明这两个对象在散列存储结构中，如Hashtable，他们<strong>“存放在同一个篮子里”</strong>。</p>
</li>
</ol>
<p>再归纳一下就是hashCode是用于查找使用的，而equals是用于比较两个对象的是否相等的。以下这段话是从别人帖子回复拷贝过来的：</p>
<blockquote>
<p>1.hashcode是用来查找的，如果你学过数据结构就应该知道，在查找和排序这一章有<br>例如内存中有这样的位置<br>0  1  2  3  4  5  6  7<br>而我有个类，这个类有个字段叫ID,我要把这个类存放在以上8个位置之一，如果不用hashcode而任意存放，那么当查找时就需要到这八个位置里挨个去找，或者用二分法一类的算法。<br>但如果用hashcode那就会使效率提高很多。<br>我们这个类中有个字段叫ID,那么我们就定义我们的hashcode为ID％8，然后把我们的类存放在取得得余数那个位置。比如我们的ID为9，9除8的余数为1，那么我们就把该类存在1这个位置，如果ID是13，求得的余数是5，那么我们就把该类放在5这个位置。这样，以后在查找该类时就可以通过ID除 8求余数直接找到存放的位置了。  </p>
<p>2.但是如果两个类有相同的hashcode怎么办那（我们假设上面的类的ID不是唯一的），例如9除以8和17除以8的余数都是1，那么这是不是合法的，回答是：可以这样。那么如何判断呢？在这个时候就需要定义 equals了。<br>也就是说，我们先通过 hashcode来判断两个类是否存放某个桶里，但这个桶里可能有很多类，那么我们就需要再通过 equals 来在这个桶里找到我们要的类。<br>那么。重写了equals()，为什么还要重写hashCode()呢？<br>想想，你要在一个桶里找东西，你必须先要找到这个桶啊，你不通过重写hashcode()来找到桶，光重写equals()有什么用啊  </p>
</blockquote>
<h2 id="HashMap简介"><a href="#HashMap简介" class="headerlink" title="HashMap简介"></a>HashMap简介</h2><h3 id="HashMap定义"><a href="#HashMap定义" class="headerlink" title="HashMap定义"></a>HashMap定义</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span><br><span class="line">    <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure>
<p>HashMap 是一个散列表，它存储的内容是键值对(key-value)映射。<br>HashMap继承于AbstractMap，实现了Map、Cloneable、java.io.Serializable接口。<br>HashMap 的实现不是同步的，这意味着它不是线程安全的。它的key、value都可以为null。此外，HashMap中的映射不是有序的。</p>
<h3 id="HashMap属性"><a href="#HashMap属性" class="headerlink" title="HashMap属性"></a>HashMap属性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认初始容量为16，必须为2的n次幂</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最大容量为2的30次方</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认加载因子为0.75f</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Entry数组，长度必须为2的n次幂</span></span><br><span class="line">    <span class="keyword">transient</span> Entry[] table;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 已存储元素的数量</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> size ;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下次扩容的临界值，size&gt;=threshold就会扩容，threshold等于capacity*load factor</span></span><br><span class="line">    <span class="keyword">int</span> threshold;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加载因子</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span> loadFactor ;</span><br></pre></td></tr></table></figure>
<p>HashMap是通过”拉链法”实现的哈希表。它包括几个重要的成员变量：table, size, threshold, loadFactor, modCount。</p>
<ul>
<li>table是一个Entry[]数组类型，而Entry实际上就是一个单向链表。哈希表的”key-value键值对”都是存储在Entry数组中的。 </li>
<li>size是HashMap的大小，它是HashMap保存的键值对的数量。 </li>
<li>threshold是HashMap的阈值，用于判断是否需要调整HashMap的容量。threshold的值=”容量*加载因子”，当HashMap中存储数据的数量达到threshold时，就需要将HashMap的容量加倍。</li>
<li>loadFactor就是加载因子。 </li>
<li>modCount是用来实现fail-fast机制的。</li>
</ul>
<p>可以看出HashMap底层是用Entry数组存储数据，同时定义了初始容量，最大容量，加载因子等参数，至于为什么容量必须是2的幂，加载因子又是什么，下面再说，先来看一下Entry的定义。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> K key ; </span><br><span class="line">        V value;</span><br><span class="line">        Entry&lt;K,V&gt; next; <span class="comment">// 指向下一个节点</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line"></span><br><span class="line">        Entry( <span class="keyword">int</span> h, K k, V v, Entry&lt;K,V&gt; n) &#123;</span><br><span class="line">            value = v;</span><br><span class="line">            next = n;</span><br><span class="line">            key = k;</span><br><span class="line">            hash = h;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> key ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> value ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123;</span><br><span class="line">           V oldValue = value;</span><br><span class="line">            value = newValue;</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Map.Entry))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            Map.Entry e = (Map.Entry)o;</span><br><span class="line">            Object k1 = getKey();</span><br><span class="line">            Object k2 = e.getKey();</span><br><span class="line">            <span class="keyword">if</span> (k1 == k2 || (k1 != <span class="keyword">null</span> &amp;&amp; k1.equals(k2))) &#123;</span><br><span class="line">                Object v1 = getValue();</span><br><span class="line">                Object v2 = e.getValue();</span><br><span class="line">                <span class="keyword">if</span> (v1 == v2 || (v1 != <span class="keyword">null</span> &amp;&amp; v1.equals(v2)))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (key ==<span class="keyword">null</span>   ? <span class="number">0</span> : key.hashCode()) ^</span><br><span class="line">                   ( value==<span class="keyword">null</span> ? <span class="number">0</span> : value.hashCode());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> getKey() + <span class="string">"="</span> + getValue();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当向HashMap中添加元素的时候调用这个方法，这里没有实现是供子类回调用</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">recordAccess</span><span class="params">(HashMap&lt;K,V&gt; m)</span> </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当从HashMap中删除元素的时候调动这个方法 ，这里没有实现是供子类回调用</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">recordRemoval</span><span class="params">(HashMap&lt;K,V&gt; m)</span> </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Entry是HashMap的内部类，它继承了Map中的Entry接口，它定义了键(key)，值(value)，和下一个节点的引用(next)，以及hash值。很明确的可以看出Entry是什么结构，它是单线链表的一个节点。<strong>也就是说HashMap的底层结构是一个数组，而数组的元素是一个单向链表。</strong><br><img src="http://7xqch5.com1.z0.glb.clouddn.com/jh3_2.jpg" alt=""></p>
<p>为什么会有这样的设计？之前介绍的List中查询时需要遍历所有的数组，为了解决这个问题HashMap采用hash算法将key散列为一个int值，这个int值对应到数组的下标，再做查询操作的时候，拿到key的散列值，根据数组下标就能直接找到存储在数组的元素。但是由于hash可能会出现相同的散列值，为了解决冲突，<strong>HashMap采用将相同的散列值存储到一个链表中，也就是说在一个链表中的元素他们的散列值绝对是相同的</strong>。找到数组下标取出链表，再遍历链表是不是比遍历整个数组效率好的多呢？</p>
<p>我们来看一下HashMap的具体实现。</p>
<h3 id="HashMap构造函数"><a href="#HashMap构造函数" class="headerlink" title="HashMap构造函数"></a>HashMap构造函数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">     * 构造一个指定初始容量和加载因子的HashMap</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">( <span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 初始容量和加载因子合法校验</span></span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException( <span class="string">"Illegal initial capacity: "</span> +</span><br><span class="line">                                               initialCapacity);</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">            initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">        <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException( <span class="string">"Illegal load factor: "</span> +</span><br><span class="line">                                               loadFactor);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Find a power of 2 &gt;= initialCapacity</span></span><br><span class="line">        <span class="comment">// 确保容量为2的n次幂，是capacity为大于initialCapacity的最小的2的n次幂</span></span><br><span class="line">        <span class="keyword">int</span> capacity = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (capacity &lt; initialCapacity)</span><br><span class="line">            capacity &lt;&lt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 赋值加载因子</span></span><br><span class="line">        <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">        <span class="comment">// 赋值扩容临界值</span></span><br><span class="line">        threshold = (<span class="keyword">int</span>)(capacity * loadFactor);</span><br><span class="line">        <span class="comment">// 初始化hash表</span></span><br><span class="line">        table = <span class="keyword">new</span> Entry[capacity];</span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 构造一个指定初始容量的HashMap</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">( <span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 构造一个使用默认初始容量(16)和默认加载因子(0.75)的HashMap</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">        threshold = (<span class="keyword">int</span>)(DEFAULT_INITIAL_CAPACITY * DEFAULT_LOAD_FACTOR);</span><br><span class="line">        table = <span class="keyword">new</span> Entry[DEFAULT_INITIAL_CAPACITY];</span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 构造一个指定map的HashMap，所创建HashMap使用默认加载因子(0.75)和足以容纳指定map的初始容量。</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 确保最小初始容量为16，并保证可以容纳指定map</span></span><br><span class="line">        <span class="keyword">this</span>(Math.max(( <span class="keyword">int</span>) (m.size() / DEFAULT_LOAD_FACTOR) + <span class="number">1</span>,</span><br><span class="line">                      DEFAULT_INITIAL_CAPACITY ), DEFAULT_LOAD_FACTOR);</span><br><span class="line">        putAllForCreate(m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> HashMap提供了三个构造函数：</p>
<ul>
<li>HashMap()：构造一个具有默认初始容量 (16) 和默认加载因子 (0.75) 的空 HashMap。</li>
<li>HashMap(int initialCapacity)：构造一个带指定初始容量和默认加载因子 (0.75) 的空 HashMap。</li>
<li>HashMap(int initialCapacity, float loadFactor)：构造一个带指定初始容量和加载因子的空 HashMap。</li>
<li>public  HashMap(Map&lt;?  extends K,  ?  extends V&gt; m)：包含“子Map”的构造函数</li>
</ul>
<p>在这里提到了两个参数：初始容量，加载因子。这两个参数是影响HashMap性能的重要参数，其中容量表示哈希表中桶的数量，初始容量是创建哈希表时的容量，加载因子是哈希表在其容量自动增加之前可以达到多满的一种尺度，它衡量的是一个散列表的空间的使用程度，负载因子越大表示散列表的装填程度越高，反之愈小。对于使用链表法的散列表来说，查找一个元素的平均时间是O(1+a)，因此如果负载因子越大，对空间的利用更充分，然而后果是查找效率的降低；如果负载因子太小，那么散列表的数据将过于稀疏，对空间造成严重浪费。系统默认负载因子为0.75，一般情况下我们是无需修改的。</p>
<h3 id="API方法摘要"><a href="#API方法摘要" class="headerlink" title="API方法摘要"></a>API方法摘要</h3><p><img src="http://7xqch5.com1.z0.glb.clouddn.com/jh3_3.png" alt=""></p>
<h2 id="HashMap源码解析-基于JDK1-6-0-45"><a href="#HashMap源码解析-基于JDK1-6-0-45" class="headerlink" title="HashMap源码解析(基于JDK1.6.0_45)"></a>HashMap源码解析(基于JDK1.6.0_45)</h2><h3 id="put方法"><a href="#put方法" class="headerlink" title="put方法"></a>put方法</h3><p>HashMap会对null值key进行特殊处理，总是放到table[0]位置<br>put过程是先计算hash然后通过hash与table.length取摸计算index值，然后将key放到table[index]位置，当table[index]已存在其它元素时，会在table[index]位置形成一个链表，将新添加的元素放在table[index]，原来的元素通过Entry的next进行链接，这样以链表形式解决hash冲突问题，当元素数量达到临界值(capactiy<em>factor)时，则进行扩容，是table数组长度变为table.length</em>2<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> putForNullKey(value); <span class="comment">//处理null值</span></span><br><span class="line">        <span class="keyword">int</span> hash = hash(key.hashCode());<span class="comment">//计算hash</span></span><br><span class="line">        <span class="keyword">int</span> i = indexFor(hash, table.length);<span class="comment">//计算在数组中的存储位置</span></span><br><span class="line">    <span class="comment">//遍历table[i]位置的链表，查找相同的key，若找到则使用新的value替换掉原来的oldValue并返回oldValue</span></span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">            Object k;</span><br><span class="line">            <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">                V oldValue = e.value;</span><br><span class="line">                e.value = value;</span><br><span class="line">                e.recordAccess(<span class="keyword">this</span>);</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//若没有在table[i]位置找到相同的key，则添加key到table[i]位置，新的元素总是在table[i]位置的第一个元素，原来的元素后移</span></span><br><span class="line">        modCount++;</span><br><span class="line">        addEntry(hash, key, value, i);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> V <span class="title">putForNullKey</span><span class="params">(V value)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 取出数组第1个位置（下标等于0）的节点，如果存在则覆盖不存在则新增，和上面的put一样不多讲，</span></span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table [<span class="number">0</span>]; e != <span class="keyword">null</span>; e = e. next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e.key == <span class="keyword">null</span>) &#123;</span><br><span class="line">                V oldValue = e. value;</span><br><span class="line">                e. value = value;</span><br><span class="line">                e.recordAccess( <span class="keyword">this</span>);</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="comment">// 如果key等于null，则hash值等于0</span></span><br><span class="line">        addEntry(<span class="number">0</span>, <span class="keyword">null</span>, value, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//添加key到table[bucketIndex]位置，新的元素总是在table[bucketIndex]的第一个元素，原来的元素后移</span></span><br><span class="line">    Entry&lt;K,V&gt; e = table[bucketIndex];</span><br><span class="line">        table[bucketIndex] = <span class="keyword">new</span> Entry&lt;K,V&gt;(hash, key, value, e);</span><br><span class="line">    <span class="comment">//判断元素个数是否达到了临界值，若已达到临界值则扩容，table长度翻倍</span></span><br><span class="line">        <span class="keyword">if</span> (size++ &gt;= threshold)</span><br><span class="line">            resize(<span class="number">2</span> * table.length);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h3><p>同样当key为null时会进行特殊处理，在table[0]的链表上查找key为null的元素<br>get的过程是先计算hash然后通过hash与table.length取摸计算index值，然后遍历table[index]上的链表，直到找到key，然后返回<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> getForNullKey();<span class="comment">//处理null值</span></span><br><span class="line">        <span class="keyword">int</span> hash = hash(key.hashCode());<span class="comment">//计算hash</span></span><br><span class="line">    <span class="comment">//在table[index]遍历查找key，若找到则返回value，找不到返回null</span></span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)];</span><br><span class="line">             e != <span class="keyword">null</span>;</span><br><span class="line">             e = e.next) &#123;</span><br><span class="line">            Object k;</span><br><span class="line">            <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k)))</span><br><span class="line">                <span class="keyword">return</span> e.value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="remove方法"><a href="#remove方法" class="headerlink" title="remove方法"></a>remove方法</h3><p>remove方法和put get类似，计算hash，计算index，然后遍历查找，将找到的元素从table[index]链表移除<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">     * 根据key删除元素</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        Entry&lt;K,V&gt; e = removeEntryForKey(key);</span><br><span class="line">        <span class="keyword">return</span> (e == <span class="keyword">null</span> ? <span class="keyword">null</span> : e. value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 根据key删除链表节点</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">final</span> Entry&lt;K,V&gt; removeEntryForKey(Object key) &#123;</span><br><span class="line">        <span class="comment">// 计算key的hash值</span></span><br><span class="line">        <span class="keyword">int</span> hash = (key == <span class="keyword">null</span>) ? <span class="number">0</span> : hash(key.hashCode());</span><br><span class="line">        <span class="comment">// 根据hash值计算key在数组的索引位置</span></span><br><span class="line">        <span class="keyword">int</span> i = indexFor(hash, table.length );</span><br><span class="line">        <span class="comment">// 找到该索引出的第一个节点</span></span><br><span class="line">        Entry&lt;K,V&gt; prev = table[i];</span><br><span class="line">        Entry&lt;K,V&gt; e = prev;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历链表（从链表第一个节点开始next），找出相同的key，</span></span><br><span class="line">        <span class="keyword">while</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; next = e. next;</span><br><span class="line">            Object k;</span><br><span class="line">            <span class="comment">// 如果hash值和key都相等，则认为相等</span></span><br><span class="line">            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                ((k = e. key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                <span class="comment">// 修改版本+1</span></span><br><span class="line">                modCount++;</span><br><span class="line">                <span class="comment">// 计数器减1</span></span><br><span class="line">                size--;</span><br><span class="line">                <span class="comment">// 如果第一个就是要删除的节点（第一个节点没有上一个节点，所以要分开判断）</span></span><br><span class="line">                <span class="keyword">if</span> (prev == e)</span><br><span class="line">                    <span class="comment">// 则将下一个节点放到table[i]位置（要删除的节点被覆盖）</span></span><br><span class="line">                    table[i] = next;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                 <span class="comment">// 否则将上一个节点的next指向当要删除节点下一个（要删除节点被忽略，没有指向了）</span></span><br><span class="line">                    prev. next = next;</span><br><span class="line">                e.recordRemoval( <span class="keyword">this</span>);</span><br><span class="line">                <span class="comment">// 返回删除的节点内容</span></span><br><span class="line">                <span class="keyword">return</span> e;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 保存当前节点为下次循环的上一个节点</span></span><br><span class="line">            prev = e;</span><br><span class="line">            <span class="comment">// 下次循环</span></span><br><span class="line">            e = next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="clear-方法"><a href="#clear-方法" class="headerlink" title="clear()方法"></a>clear()方法</h3><p>clear方法非常简单，就是遍历table然后把每个位置置为null，同时修改元素个数为0<br>需要注意的是clear方法只会清楚里面的元素，并不会重置capactiy<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        modCount++;</span><br><span class="line">        Entry[] tab = table;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tab.length; i++)</span><br><span class="line">            tab[i] = <span class="keyword">null</span>;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="resize方法"><a href="#resize方法" class="headerlink" title="resize方法"></a>resize方法</h3><p>resize方法在hashmap中并没有公开，这个方法实现了非常重要的hashmap扩容，具体过程为：先创建一个容量为table.length<em>2的新table，修改临界值，然后把table里面元素计算hash值并使用hash与table.length</em>2重新计算index放入到新的table里面<br>这里需要注意下是用<strong>每个元素的hash全部重新计算index</strong>，而不是简单的把原table对应index位置元素简单的移动到新table对应位置<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">( <span class="keyword">int</span> newCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 当前数组</span></span><br><span class="line">        Entry[] oldTable = table;</span><br><span class="line">        <span class="comment">// 当前数组容量</span></span><br><span class="line">        <span class="keyword">int</span> oldCapacity = oldTable.length ;</span><br><span class="line">        <span class="comment">// 如果当前数组已经是默认最大容量MAXIMUM_CAPACITY ，则将临界值改为Integer.MAX_VALUE 返回</span></span><br><span class="line">        <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用新的容量创建一个新的链表数组</span></span><br><span class="line">        Entry[] newTable = <span class="keyword">new</span> Entry[newCapacity];</span><br><span class="line">        <span class="comment">// 将当前数组中的元素都移动到新数组中</span></span><br><span class="line">        transfer(newTable);</span><br><span class="line">        <span class="comment">// 将当前数组指向新创建的数组</span></span><br><span class="line">        table = newTable;</span><br><span class="line">        <span class="comment">// 重新计算临界值</span></span><br><span class="line">        threshold = (<span class="keyword">int</span>)(newCapacity * loadFactor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Transfers all entries from current table to newTable.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 当前数组</span></span><br><span class="line">        Entry[] src = table;</span><br><span class="line">        <span class="comment">// 新数组长度</span></span><br><span class="line">        <span class="keyword">int</span> newCapacity = newTable.length ;</span><br><span class="line">        <span class="comment">// 遍历当前数组的元素，重新计算每个元素所在数组位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; src. length; j++) &#123;</span><br><span class="line">            <span class="comment">// 取出数组中的链表第一个节点</span></span><br><span class="line">            Entry&lt;K,V&gt; e = src[j];</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 将旧链表位置置空</span></span><br><span class="line">                src[j] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">// 循环链表，挨个将每个节点插入到新的数组位置中</span></span><br><span class="line">                do &#123;</span><br><span class="line">                    <span class="comment">// 取出链表中的当前节点的下一个节点</span></span><br><span class="line">                    Entry&lt;K,V&gt; next = e. next;</span><br><span class="line">                    <span class="comment">// 重新计算该链表在数组中的索引位置</span></span><br><span class="line">                    <span class="keyword">int</span> i = indexFor(e. hash, newCapacity);</span><br><span class="line">                    <span class="comment">// 将下一个节点指向newTable[i]</span></span><br><span class="line">                    e. next = newTable[i];</span><br><span class="line">                    <span class="comment">// 将当前节点放置在newTable[i]位置</span></span><br><span class="line">                    newTable[i] = e;</span><br><span class="line">                    <span class="comment">// 下一次循环</span></span><br><span class="line">                    e = next;</span><br><span class="line">                &#125; <span class="keyword">while</span> (e != <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>transfer方法中，由于数组的容量已经变大，也就导致hash算法indexFor已经发生变化，原先在一个链表中的元素，在新的hash下可能会产生不同的散列值，so所有元素都要重新计算后安顿一番。注意在do while循环的过程中，每次循环都是将下个节点指向newTable[i] ，是因为如果有相同的散列值i，上个节点已经放置在newTable[i]位置，这里还是下一个节点的next指向上一个节点（不知道这里是否能理解，画个图理解下吧）。</p>
<p>Map中的元素越多，hash冲突的几率也就越大，数组长度是固定的，所以导致链表越来越长，那么查询的效率当然也就越低下了。还记不记得同时数组容器的ArrayList怎么做的，扩容！而HashMap的扩容resize，需要将所有的元素重新计算后，一个个重新排列到新的数组中去，这是非常低效的，和ArrayList一样，在可以预知容量大小的情况下，提前预设容量会减少HashMap的扩容，提高性能。</p>
<p>再来看看加载因子的作用，如果加载因子越大，数组填充的越满，这样可以有效的利用空间，但是有一个弊端就是可能会导致冲突的加大，链表过长，反过来却又会造成内存空间的浪费。所以只能需要在空间和时间中找一个平衡点，那就是设置有效的加载因子。我们知道，很多时候为了提高查询效率的做法都是牺牲空间换取时间，到底该怎么取舍，那就要具体分析了。</p>
<h3 id="containsKey方法"><a href="#containsKey方法" class="headerlink" title="containsKey方法"></a>containsKey方法</h3><p>containsKey方法是先计算hash然后使用hash和table.length取摸得到index值，遍历table[index]元素查找是否包含key相同的值<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsKey</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getEntry(key) != <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> Entry&lt;K,V&gt; getEntry(Object key) &#123;</span><br><span class="line">    <span class="comment">// 获取哈希值</span></span><br><span class="line">    <span class="comment">// HashMap将“key为null”的元素存储在table[0]位置，“key不为null”的则调用hash()计算哈希值</span></span><br><span class="line">    <span class="keyword">int</span> hash = (key == <span class="keyword">null</span>) ? <span class="number">0</span> : hash(key.hashCode());</span><br><span class="line">    <span class="comment">// 在“该hash值对应的链表”上查找“键值等于key”的元素</span></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)];</span><br><span class="line">         e != <span class="keyword">null</span>;</span><br><span class="line">         e = e.next) &#123;</span><br><span class="line">        Object k;</span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">            ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>getEntry() 的作用就是<strong>返回“键为key”的键值对</strong>，它的实现源码中已经进行了说明。<br>这里需要强调的是：<strong>HashMap将“key为null”的元素都放在table的位置0处</strong>，即table[0]中；“key不为null”的放在table的其余位置！</p>
<h3 id="containsValue方法"><a href="#containsValue方法" class="headerlink" title="containsValue方法"></a>containsValue方法</h3><p>containsValue方法就比较粗暴了，就是直接遍历所有元素直到找到value，由此可见HashMap的containsValue方法本质上和普通数组和list的contains方法没什么区别，你别指望它会像containsKey那么高效<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsValue</span><span class="params">(Object value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 若“value为null”，则调用containsNullValue()查找</span></span><br><span class="line">    <span class="keyword">if</span> (value == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> containsNullValue();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若“value不为null”，则查找HashMap中是否有值为value的节点。</span></span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tab.length ; i++)</span><br><span class="line">        <span class="keyword">for</span> (Entry e = tab[i] ; e != <span class="keyword">null</span> ; e = e.next)</span><br><span class="line">            <span class="keyword">if</span> (value.equals(e.value))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>containsNullValue() 的作用<strong>判断HashMap中是否包含“值为null”的元素</strong>。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">containsNullValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tab.length ; i++)</span><br><span class="line">        <span class="keyword">for</span> (Entry e = tab[i] ; e != <span class="keyword">null</span> ; e = e.next)</span><br><span class="line">            <span class="keyword">if</span> (e.value == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="entrySet-、values-、keySet-方法"><a href="#entrySet-、values-、keySet-方法" class="headerlink" title="entrySet()、values()、keySet()方法"></a>entrySet()、values()、keySet()方法</h3><p>它们3个的原理类似，这里以entrySet()为例来说明。<br>entrySet()的作用是<strong>返回“HashMap中所有Entry的集合”，它是一个集合。</strong>实现代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回“HashMap的Entry集合”</span></span><br><span class="line"><span class="keyword">public</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() &#123;</span><br><span class="line">    <span class="keyword">return</span> entrySet0();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回“HashMap的Entry集合”，它实际是返回一个EntrySet对象</span></span><br><span class="line"><span class="keyword">private</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet0() &#123;</span><br><span class="line">    Set&lt;Map.Entry&lt;K,V&gt;&gt; es = entrySet;</span><br><span class="line">    <span class="keyword">return</span> es != <span class="keyword">null</span> ? es : (entrySet = <span class="keyword">new</span> EntrySet());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// EntrySet对应的集合</span></span><br><span class="line"><span class="comment">// EntrySet继承于AbstractSet，说明该集合中没有重复的EntrySet。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">EntrySet</span> <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() &#123;</span><br><span class="line">        <span class="keyword">return</span> newEntryIterator();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Map.Entry))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Map.Entry&lt;K,V&gt; e = (Map.Entry&lt;K,V&gt;) o;</span><br><span class="line">        Entry&lt;K,V&gt; candidate = getEntry(e.getKey());</span><br><span class="line">        <span class="keyword">return</span> candidate != <span class="keyword">null</span> &amp;&amp; candidate.equals(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> removeMapping(o) != <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        HashMap.<span class="keyword">this</span>.clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>HashMap是通过拉链法实现的散列表。表现在HashMap包括许多的Entry，而每一个Entry本质上又是一个单向链表。那么HashMap遍历key-value键值对的时候，是如何逐个去遍历的呢？</p>
<p>下面我们就看看<strong>HashMap是如何通过entrySet()遍历的。</strong><br>entrySet()实际上是通过newEntryIterator()实现的。 下面我们看看它的代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回一个“entry迭代器”</span></span><br><span class="line">Iterator&lt;Map.Entry&lt;K,V&gt;&gt; newEntryIterator()   &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> EntryIterator();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Entry的迭代器</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">EntryIterator</span> <span class="keyword">extends</span> <span class="title">HashIterator</span>&lt;<span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Map.Entry&lt;K,V&gt; next() &#123;</span><br><span class="line">        <span class="keyword">return</span> nextEntry();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// HashIterator是HashMap迭代器的抽象出来的父类，实现了公共了函数。</span></span><br><span class="line"><span class="comment">// 它包含“key迭代器(KeyIterator)”、“Value迭代器(ValueIterator)”和“Entry迭代器(EntryIterator)”3个子类。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">HashIterator</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 下一个元素</span></span><br><span class="line">    Entry&lt;K,V&gt; next;</span><br><span class="line">    <span class="comment">// expectedModCount用于实现fast-fail机制。</span></span><br><span class="line">    <span class="keyword">int</span> expectedModCount;</span><br><span class="line">    <span class="comment">// 当前索引</span></span><br><span class="line">    <span class="keyword">int</span> index;</span><br><span class="line">    <span class="comment">// 当前元素</span></span><br><span class="line">    Entry&lt;K,V&gt; current;</span><br><span class="line"></span><br><span class="line">    HashIterator() &#123;</span><br><span class="line">        expectedModCount = modCount;</span><br><span class="line">        <span class="keyword">if</span> (size &gt; <span class="number">0</span>) &#123; <span class="comment">// advance to first entry</span></span><br><span class="line">            Entry[] t = table;</span><br><span class="line">            <span class="comment">// 将next指向table中第一个不为null的元素。</span></span><br><span class="line">            <span class="comment">// 这里利用了index的初始值为0，从0开始依次向后遍历，直到找到不为null的元素就退出循环。</span></span><br><span class="line">            <span class="keyword">while</span> (index &lt; t.length &amp;&amp; (next = t[index++]) == <span class="keyword">null</span>)</span><br><span class="line">                ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> next != <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取下一个元素</span></span><br><span class="line">    <span class="keyword">final</span> Entry&lt;K,V&gt; nextEntry() &#123;</span><br><span class="line">        <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        Entry&lt;K,V&gt; e = next;</span><br><span class="line">        <span class="keyword">if</span> (e == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注意！！！</span></span><br><span class="line">        <span class="comment">// 一个Entry就是一个单向链表</span></span><br><span class="line">        <span class="comment">// 若该Entry的下一个节点不为空，就将next指向下一个节点;</span></span><br><span class="line">        <span class="comment">// 否则，将next指向下一个链表(也是下一个Entry)的不为null的节点。</span></span><br><span class="line">        <span class="keyword">if</span> ((next = e.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            Entry[] t = table;</span><br><span class="line">            <span class="keyword">while</span> (index &lt; t.length &amp;&amp; (next = t[index++]) == <span class="keyword">null</span>)</span><br><span class="line">                ;</span><br><span class="line">        &#125;</span><br><span class="line">        current = e;</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除当前元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (current == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">        <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        Object k = current.key;</span><br><span class="line">        current = <span class="keyword">null</span>;</span><br><span class="line">        HashMap.<span class="keyword">this</span>.removeEntryForKey(k);</span><br><span class="line">        expectedModCount = modCount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当我们通过entrySet()获取到的Iterator的next()方法去遍历HashMap时，实际上调用的是 nextEntry() 。而nextEntry()的实现方式，先遍历Entry(根据Entry在table中的序号，从小到大的遍历)；然后对每个Entry(即每个单向链表)，逐个遍历。</p>
<h3 id="hash和indexFor"><a href="#hash和indexFor" class="headerlink" title="hash和indexFor"></a>hash和indexFor</h3><p>indexFor中的h &amp; (length-1)就相当于h%length，用于计算index也就是在table数组中的下标<br>hash方法是对hashcode进行二次散列，以获得更好的散列值<br>为了更好理解这里我们可以把这两个方法简化为 int index= key.hashCode()/table.length,以put中的方法为例可以这样替换<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> hash = hash(key.hashCode());<span class="comment">//计算hash</span></span><br><span class="line"><span class="keyword">int</span> i = indexFor(hash, table.length);<span class="comment">//计算在数组中的存储位置</span></span><br><span class="line"><span class="comment">//上面这两行可以这样简化</span></span><br><span class="line"><span class="keyword">int</span> i = key.key.hashCode()%table.length;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(<span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// This function ensures that hashCodes that differ only by</span></span><br><span class="line">    <span class="comment">// constant multiples at each bit position have a bounded</span></span><br><span class="line">    <span class="comment">// number of collisions (approximately 8 at default load factor).</span></span><br><span class="line">    h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);</span><br><span class="line">    <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> h &amp; (length-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="HashMap和Hashtable的区别"><a href="#HashMap和Hashtable的区别" class="headerlink" title="HashMap和Hashtable的区别"></a>HashMap和Hashtable的区别</h2><ol>
<li><strong>两者最主要的区别在于Hashtable是线程安全，而HashMap则非线程安全</strong><br>Hashtable的实现方法里面都添加了synchronized关键字来确保线程同步，因此相对而言HashMap性能会高一些，我们平时使用时若无特殊需求建议使用HashMap，在多线程环境下若使用HashMap需要使用Collections.synchronizedMap()方法来获取一个线程安全的集合（Collections.synchronizedMap()实现原理是Collections定义了一个SynchronizedMap的内部类，这个类实现了Map接口，在调用方法时使用synchronized来保证线程同步,当然了实际上操作的还是我们传入的HashMap实例，简单的说就是Collections.synchronizedMap()方法帮我们在操作HashMap时自动添加了synchronized来实现线程同步，类似的其它Collections.synchronizedXX方法也是类似原理）</li>
<li>HashMap可以使用null作为key，而Hashtable则不允许null作为key<br>虽说HashMap支持null值作为key，不过建议还是尽量避免这样使用，因为一旦不小心使用了，若因此引发一些问题，排查起来很是费事<br>HashMap以null作为key时，总是存储在table数组的第一个节点上</li>
<li>HashMap是对Map接口的实现，HashTable实现了Map接口和Dictionary抽象类</li>
<li>HashMap的初始容量为16，Hashtable初始容量为11，两者的填充因子默认都是0.75<br>HashMap扩容时是当前容量翻倍即:capacity<em>2，Hashtable扩容时是容量翻倍+1即:capacity</em>2+1</li>
<li>HashMap和Hashtable的底层实现都是数组+链表结构实现</li>
<li>两者计算hash的方法不同<br>Hashtable计算hash是直接使用key的hashcode对table数组的长度直接进行取模<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> hash = key.hashCode();</span><br><span class="line"><span class="keyword">int</span> index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>HashMap计算hash对key的hashcode进行了二次hash，以获得更好的散列值，然后对table数组长度取摸<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(<span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// This function ensures that hashCodes that differ only by</span></span><br><span class="line">        <span class="comment">// constant multiples at each bit position have a bounded</span></span><br><span class="line">        <span class="comment">// number of collisions (approximately 8 at default load factor).</span></span><br><span class="line">        h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);</span><br><span class="line">        <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> h &amp; (length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>该文为本人学习的笔记，方便以后自己跳槽前复习。参考网上各大帖子，取其精华整合自己的理解而成。集合框架源码面试经常会问，所以解读源码十分必要,希望对你有用。<br><a href="http://www.cnblogs.com/chenssy/p/3521565.html" target="_blank" rel="external">java提高篇（二三）—–HashMap</a><br><a href="http://www.cnblogs.com/skywang12345/p/3310835.html" target="_blank" rel="external">Java 集合系列10之 HashMap详细介绍(源码解析)和使用示例</a><br><a href="http://zhangshixi.iteye.com/blog/672697" target="_blank" rel="external">深入Java集合学习系列：HashMap的实现原理</a><br><a href="http://www.cnblogs.com/tstd/p/5055286.html" target="_blank" rel="external">给jdk写注释系列之jdk1.6容器(4)-HashMap源码解析</a><br><a href="http://zhangshixi.iteye.com/blog/672697" target="_blank" rel="external">深入Java集合学习系列：HashMap的实现原理</a></p>
<h1 id="整理的集合框架思维导图"><a href="#整理的集合框架思维导图" class="headerlink" title="整理的集合框架思维导图"></a>整理的集合框架思维导图</h1><p>个人整理的Java集合框架思维导图，动态维护。导出的图片无法查看备注的一些信息，所以需要源文件的童鞋可以关注我个人主页上的公众号，回复<strong>Java集合框架</strong>即可获取源文件。<br><img src="http://7xqch5.com1.z0.glb.clouddn.com/jhswdt.png" alt=""></p>
<hr>
<p>博主弄了个java学习资源的公众号，学习资源超级多，视频，电子书，最新开发工具一个都不能少，已全部分享到百度云盘，求资源共享，打造一个学习方便，工作方便的java公众号，开源开源，有需求的可以关注~撒花<br>  <img src="http://7xqch5.com1.z0.glb.clouddn.com/javaLearn.PNG" alt=""></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Java集合干货系列/">Java集合干货系列</a>
    </div>


      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/3/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                <i class="fa fa-copyright"></i> 
                2016-2017 Teng Jun
            </div>
            <div class="footer-right">
                <a href="http://hexo.io/" target="_blank" title="快速、简洁且高效的博客框架">Hexo</a>  Theme <a href="https://github.com/MOxFIVE/hexo-theme-yelee" target="_blank" title="简而不减 Hexo 双栏博客主题  v3.5">Yelee</a> by MOxFIVE <i class="fa fa-heart animated infinite pulse"></i>
            </div>
        </div>
        
            <div class="visit">
                
                    <span id="busuanzi_container_site_pv" style='display:none'>
                        <span id="site-visit" title="本站到访数"><i class="fa fa-user" aria-hidden="true"></i><span id="busuanzi_value_site_uv"></span>
                        </span>
                    </span>
                
                
                    <span>| </span>
                
                
                    <span id="busuanzi_container_page_pv" style='display:none'>
                        <span id="page-visit"  title="本页阅读量"><i class="fa fa-eye animated infinite pulse" aria-hidden="true"></i><span id="busuanzi_value_page_pv"></span>
                        </span>
                    </span>
                
            </div>
        
    </div>
</footer>
    </div>
    
<script data-main="/js/main.js" src="//cdn.bootcss.com/require.js/2.2.0/require.min.js"></script>

    <script>
        $(document).ready(function() {
            var iPad = window.navigator.userAgent.indexOf('iPad');
            if (iPad > -1 || $(".left-col").css("display") === "none") {
                var bgColorList = ["#9db3f4", "#414141", "#e5a859", "#f5dfc6", "#c084a0", "#847e72", "#cd8390", "#996731"];
                var bgColor = Math.ceil(Math.random() * (bgColorList.length - 1));
                $("body").css({"background-color": bgColorList[bgColor], "background-size": "cover"});
            }
            else {
                var backgroundnum = 5;
                var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
                $("body").css({"background": backgroundimg, "background-attachment": "fixed", "background-size": "cover"});
            }
        })
    </script>


    
        <script>
            if ($(".left-col").is(":visible")) {
                var duoshuoQuery = {short_name:"tengj"};
                (function() {
                    var d = document, s = d.createElement('script');
                    s.src = 'http://static.duoshuo.com/embed.js';
                    s.async = true; s.charset = 'UTF-8';
                    (d.head || d.body).appendChild(s);
                })();

                $(document).ready(function(){
                    var $duoshuoCount = $(".ds-thread-count");
                    $duoshuoCount.bind("DOMNodeInserted", function(e) {
                        var num = $(this).text().replace(/[^0-9]/ig,"");
                        $(this).siblings(".count-comment").text(num);
                        $(this).remove();
                    })
                })
            }
        </script>
    

     




<div class="scroll" id="scroll">
    <a href="#" title="返回顶部"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments" onclick="load$hide();" title="查看评论"><i class="fa fa-comments-o"></i></a>
    <a href="#footer" title="转到底部"><i class="fa fa-arrow-down"></i></a>
</div>
<script>
    // Open in New Window
    
        var oOpenInNew = {
            
            
            
            
            
            
             archives: ".archive-article-title", 
             miniArchives: "a.post-list-link", 
            
             friends: "#js-friends a", 
             socail: ".social a" 
        }
        for (var x in oOpenInNew) {
            $(oOpenInNew[x]).attr("target", "_blank");
        }
    
</script>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
  </div>
</body>
</html>